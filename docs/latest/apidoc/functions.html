


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Functions &mdash; QuTiP 4.4 Documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Change Log" href="../changelog.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apidoc.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#manipulation-and-creation-of-states-and-operators">Manipulation and Creation of States and Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.states">Quantum States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.operators">Quantum Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.random_objects">Random Operators and States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.three_level_atom">Three-Level Atoms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.superoperator">Superoperators and Liouvillians</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.superop_reps">Superoperator Representations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functions-acting-on-states-and-operators">Functions acting on states and operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.expect">Expectation Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.tensor">Tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.partial_transpose">Partial Transpose</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.entropy">Entropy Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.metrics">Density Matrix Metrics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#continuous-variables">Continuous Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dynamics-and-time-evolution">Dynamics and Time-Evolution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.sesolve">Schrödinger Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.mesolve">Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.mcsolve">Monte Carlo Evolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.essolve">Exponential Series</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.bloch_redfield">Bloch-Redfield Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.floquet">Floquet States and Floquet-Markov Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.stochastic">Stochastic Schrödinger Equation and Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.correlation">Correlation Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.steadystate">Steady-state Solvers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.propagator">Propagators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.rhs_generate">Time-dependent problems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.scattering">Scattering in Quantum Optical Systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.piqs">Permutational Invariance</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#visualization">Visualization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.wigner">Pseudoprobability Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.visualization">Graphs and Visualization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.tomography">Quantum Process Tomography</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-information-processing">Quantum Information Processing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.gates">Gates</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.qubits">Qubits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.algorithms.qft">Algorithms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-qutip.nonmarkov.transfertensor">Non-Markovian Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-qutip.control.pulseoptim">Optimal control</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#grape">GRAPE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crab">CRAB</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#utility-functions">Utility Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.graph">Graph Theory Routines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-utilities">Utility Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.fileio">File I/O Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.parallel">Parallelization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.ipynbtools">IPython Notebook Tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="apidoc.html">API documentation</a> &raquo;</li>
        
      <li>Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<span id="id1"></span><h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="manipulation-and-creation-of-states-and-operators">
<h2>Manipulation and Creation of States and Operators<a class="headerlink" href="#manipulation-and-creation-of-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.states">
<span id="quantum-states"></span><h3>Quantum States<a class="headerlink" href="#module-qutip.states" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.states.basis">
<code class="sig-name descname">basis</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">n=0</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the vector representation of a Fock state.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Integer corresponding to desired number state, defaults
to 0 if omitted.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Qobj representing the requested number state <code class="docutils literal notranslate"><span class="pre">|n&gt;</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A subtle incompatibility with the quantum optics toolbox: In QuTiP:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">ground</span> <span class="n">state</span>
</pre></div>
</div>
<p>but in the qotoolbox:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ground</span> <span class="n">state</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.bell_state">
<code class="sig-name descname">bell_state</code><span class="sig-paren">(</span><em class="sig-param">state='00'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#bell_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.bell_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bell state:</p>
<blockquote>
<div><p><a href="#id2"><span class="problematic" id="id3">|</span></a>B00&gt; = 1 / sqrt(2)*[<a href="#id4"><span class="problematic" id="id5">|</span></a>0&gt;|0&gt;+|1&gt;|1&gt;]
<a href="#id6"><span class="problematic" id="id7">|</span></a>B01&gt; = 1 / sqrt(2)*[<a href="#id8"><span class="problematic" id="id9">|</span></a>0&gt;|0&gt;-<a href="#id10"><span class="problematic" id="id11">|</span></a>1&gt;|1&gt;]
<a href="#id12"><span class="problematic" id="id13">|</span></a>B10&gt; = 1 / sqrt(2)*[<a href="#id14"><span class="problematic" id="id15">|</span></a>0&gt;|1&gt;+|1&gt;|0&gt;]
<a href="#id16"><span class="problematic" id="id17">|</span></a>B11&gt; = 1 / sqrt(2)*[<a href="#id18"><span class="problematic" id="id19">|</span></a>0&gt;|1&gt;-<a href="#id20"><span class="problematic" id="id21">|</span></a>1&gt;|0&gt;]</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Bell_state</strong><span class="classifier">qobj</span></dt><dd><p>Bell state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.bra">
<code class="sig-name descname">bra</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">dim=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#bra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.bra" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a multiparticle bra state for a list or string,
where each element stands for state of the respective particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seq</strong><span class="classifier">str / list of ints or characters</span></dt><dd><p>Each element defines state of the respective particle.
(e.g. [1,1,0,1] or a string “1101”).
For qubits it is also possible to use the following conventions:
- ‘g’/’e’ (ground and excited state)
- ‘u’/’d’ (spin up and down)
- ‘H’/’V’ (horizontal and vertical polarization)
Note: for dimension &gt; 9 you need to use a list.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int (default: 2) / list of ints</span></dt><dd><p>Space dimension for each particle:
int if there are the same, list if they are different.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bra</strong><span class="classifier">qobj</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;10&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  1.  0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;Hue&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.  0.  0.  0.  0.  0.  0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;12&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  0.  0.  0.  1.  0.  0.  0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;31&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  0.  0.  0.  0.  0.  1.  0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.coherent">
<code class="sig-name descname">coherent</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">alpha</em>, <em class="sig-param">offset=0</em>, <em class="sig-param">method='operator'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#coherent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a coherent state with eigenvalue alpha.</p>
<p>Constructed using displacement operator on vacuum state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float/complex</span></dt><dd><p>Eigenvalue of coherent state.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state. Using a non-zero offset will make the
default method ‘analytic’.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘operator’, ‘analytic’}</span></dt><dd><p>Method for generating coherent state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Qobj quantum object for coherent state</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Select method ‘operator’ (default) or ‘analytic’. With the
‘operator’ method, the coherent state is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size ‘N’. This method guarantees that the
resulting state is normalized. With ‘analytic’ method the coherent state
is generated using the analytical formula for the coherent state
coefficients in the Fock basis. This method does not guarantee that the
state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mf">0.25</span><span class="n">j</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[  9.69233235e-01+0.j        ]</span>
<span class="go"> [  0.00000000e+00+0.24230831j]</span>
<span class="go"> [ -4.28344935e-02+0.j        ]</span>
<span class="go"> [  0.00000000e+00-0.00618204j]</span>
<span class="go"> [  7.80904967e-04+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.coherent_dm">
<code class="sig-name descname">coherent_dm</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">alpha</em>, <em class="sig-param">offset=0</em>, <em class="sig-param">method='operator'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#coherent_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.coherent_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a coherent state.</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.coherent" title="qutip.states.coherent"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.coherent</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float/complex</span></dt><dd><p>Eigenvalue for coherent state.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘operator’, ‘analytic’}</span></dt><dd><p>Method for generating coherent density matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix representation of coherent state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Select method ‘operator’ (default) or ‘analytic’. With the
‘operator’ method, the coherent density matrix is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size ‘N’. This method guarantees that the
resulting density matrix is normalized. With ‘analytic’ method the coherent
density matrix is generated using the analytical formula for the coherent
state coefficients in the Fock basis. This method does not guarantee that
the state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.25</span><span class="n">j</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.93941695+0.j          0.00000000-0.23480733j -0.04216943+0.j        ]</span>
<span class="go"> [ 0.00000000+0.23480733j  0.05869011+0.j          0.00000000-0.01054025j]</span>
<span class="go"> [-0.04216943+0.j          0.00000000+0.01054025j  0.00189294+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_state_dictionaries">
<code class="sig-name descname">enr_state_dictionaries</code><span class="sig-paren">(</span><em class="sig-param">dims</em>, <em class="sig-param">excitations</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#enr_state_dictionaries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_state_dictionaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of states, and lookup-dictionaries for translating
a state tuple to a state index, and vice versa, for a system with a given
number of components and maximum number of excitations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: list</strong></dt><dd><p>A list with the number of states in each sub-system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum numbers of dimension</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>nstates, state2idx, idx2state: integer, dict, dict</dt><dd><p>The number of states <cite>nstates</cite>, a dictionary for looking up state
indices from a state tuple, and a dictionary for looking up state
state tuples from state indices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_thermal_dm">
<code class="sig-name descname">enr_thermal_dm</code><span class="sig-paren">(</span><em class="sig-param">dims</em>, <em class="sig-param">excitations</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#enr_thermal_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density operator for a thermal state in the excitation-number-
restricted state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments.
See the documentation for enr_fock for a more detailed description of
these arguments. The temperature of each mode in dims is specified by
the average number of excitatons <cite>n</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>n</strong><span class="classifier">integer</span></dt><dd><p>The average number of exciations in the thermal state. <cite>n</cite> can be
a float (which then applies to each mode), or a list/array of the same
length as dims, in which each element corresponds specifies the
temperature of the corresponding mode.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">Qobj</span></dt><dd><p>Thermal state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_fock">
<code class="sig-name descname">enr_fock</code><span class="sig-paren">(</span><em class="sig-param">dims</em>, <em class="sig-param">excitations</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#enr_fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Fock state representation in a excitation-number restricted
state space. The <cite>dims</cite> argument is a list of integers that define the
number of quantums states of each component of a composite quantum system,
and the <cite>excitations</cite> specifies the maximum number of excitations for
the basis states that are to be included in the state space. The <cite>state</cite>
argument is a tuple of integers that specifies the state (in the number
basis representation) for which to generate the Fock state representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list of integers</span></dt><dd><p>The state in the number basis representation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">Qobj</span></dt><dd><p>A Qobj instance that represent a Fock state in the exication-number-
restricted state space defined by <cite>dims</cite> and <cite>exciations</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.fock">
<code class="sig-name descname">fock</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">n=0</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bosonic Fock (number) state.</p>
<p>Same as <a class="reference internal" href="#qutip.states.basis" title="qutip.states.basis"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.basis</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of states in the Hilbert space.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span></code> for desired number state, defaults to 0 if omitted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Requested number state <span class="math notranslate nohighlight">\(\left|n\right&gt;\)</span>.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fock</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.fock_dm">
<code class="sig-name descname">fock_dm</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">n=0</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#fock_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.fock_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a Fock state</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.fock" title="qutip.states.fock"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.fock</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span></code> for desired number state, defaults to 0 if omitted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix representation of Fock state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ghz_state">
<code class="sig-name descname">ghz_state</code><span class="sig-paren">(</span><em class="sig-param">N=3</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#ghz_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.ghz_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the N-qubit GHZ-state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int (default=3)</span></dt><dd><p>Number of qubits in state</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G</strong><span class="classifier">qobj</span></dt><dd><p>N-qubit GHZ-state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.maximally_mixed_dm">
<code class="sig-name descname">maximally_mixed_dm</code><span class="sig-paren">(</span><em class="sig-param">N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#maximally_mixed_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.maximally_mixed_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximally mixed density matrix for a Hilbert space of
dimension N.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Thermal state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ket">
<code class="sig-name descname">ket</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">dim=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a multiparticle ket state for a list or string,
where each element stands for state of the respective particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seq</strong><span class="classifier">str / list of ints or characters</span></dt><dd><p>Each element defines state of the respective particle.
(e.g. [1,1,0,1] or a string “1101”).
For qubits it is also possible to use the following conventions:
- ‘g’/’e’ (ground and excited state)
- ‘u’/’d’ (spin up and down)
- ‘H’/’V’ (horizontal and vertical polarization)
Note: for dimension &gt; 9 you need to use a list.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int (default: 2) / list of ints</span></dt><dd><p>Space dimension for each particle:
int if there are the same, list if they are different.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">qobj</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;10&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;Hue&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;12&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;31&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ket2dm">
<code class="sig-name descname">ket2dm</code><span class="sig-paren">(</span><em class="sig-param">Q</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#ket2dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.ket2dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes input ket or bra vector and returns density matrix
formed by outer product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">qobj</span></dt><dd><p>Ket or bra type quantum object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix formed by outer product of <cite>Q</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2dm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.phase_basis">
<code class="sig-name descname">phase_basis</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">m</em>, <em class="sig-param">phi0=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#phase_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.phase_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis vector for the mth phase of the Pegg-Barnett phase operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis vectors in Hilbert space.</p>
</dd>
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>Integer corresponding to the mth discrete phase phi_m=phi0+2*pi*m/N</p>
</dd>
<dt><strong>phi0</strong><span class="classifier">float (default=0)</span></dt><dd><p>Reference phase angle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Ket vector for mth Pegg-Barnett phase operator basis state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett basis states form a complete set over the truncated
Hilbert space.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.states.projection">
<code class="sig-name descname">projection</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">n</em>, <em class="sig-param">m</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#projection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>The projection operator that projects state <span class="math notranslate nohighlight">\(|m&gt;\)</span> on state <span class="math notranslate nohighlight">\(|n&gt;\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>n, m</strong><span class="classifier">float</span></dt><dd><p>The number states in the projection.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the projector.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Requested projection operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.qutrit_basis">
<code class="sig-name descname">qutrit_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#qutrit_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.qutrit_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level system (qutrit)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qstates</strong><span class="classifier">array</span></dt><dd><p>Array of qutrit basis vectors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.singlet_state">
<code class="sig-name descname">singlet_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#singlet_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.singlet_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the two particle singlet-state:</p>
<blockquote>
<div><p><a href="#id22"><span class="problematic" id="id23">|</span></a>S&gt;=1/sqrt(2)*[<a href="#id24"><span class="problematic" id="id25">|</span></a>0&gt;|1&gt;-<a href="#id26"><span class="problematic" id="id27">|</span></a>1&gt;|0&gt;]</p>
</div></blockquote>
<p>that is identical to the fourth bell state.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Bell_state</strong><span class="classifier">qobj</span></dt><dd><p><a href="#id28"><span class="problematic" id="id29">|</span></a>B11&gt; Bell state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.spin_state">
<code class="sig-name descname">spin_state</code><span class="sig-paren">(</span><em class="sig-param">j</em>, <em class="sig-param">m</em>, <em class="sig-param">type='ket'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#spin_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.spin_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the spin state <a href="#id30"><span class="problematic" id="id31">|</span></a>j, m&gt;, i.e.  the eigenstate
of the spin-j Sz operator with eigenvalue m.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>The spin of the state ().</p>
</dd>
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>Eigenvalue of the spin-j Sz operator.</p>
</dd>
<dt><strong>type</strong><span class="classifier">string {‘ket’, ‘bra’, ‘dm’}</span></dt><dd><p>Type of state to generate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Qobj quantum object for spin state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.spin_coherent">
<code class="sig-name descname">spin_coherent</code><span class="sig-paren">(</span><em class="sig-param">j</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em>, <em class="sig-param">type='ket'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#spin_coherent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.spin_coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the coherent spin state <a href="#id32"><span class="problematic" id="id33">|</span></a>theta, phi&gt;.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>The spin of the state.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Angle from z axis.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float</span></dt><dd><p>Angle from x axis.</p>
</dd>
<dt><strong>type</strong><span class="classifier">string {‘ket’, ‘bra’, ‘dm’}</span></dt><dd><p>Type of state to generate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Qobj quantum object for spin coherent state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_enumerate">
<code class="sig-name descname">state_number_enumerate</code><span class="sig-paren">(</span><em class="sig-param">dims</em>, <em class="sig-param">excitations=None</em>, <em class="sig-param">state=None</em>, <em class="sig-param">idx=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_number_enumerate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_enumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that enumerate all the state number arrays (quantum numbers on
the form [n1, n2, n3, …]) for a system with dimensions given by dims.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">state_number_enumerate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="go">[ 0  0 ]</span>
<span class="go">[ 0  1 ]</span>
<span class="go">[ 1  0 ]</span>
<span class="go">[ 1  1 ]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list</span></dt><dd><p>Current state in the iteration. Used internally.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer (None)</span></dt><dd><p>Restrict state space to states with excitation numbers below or
equal to this value.</p>
</dd>
<dt><strong>idx</strong><span class="classifier">integer</span></dt><dd><p>Current index in the iteration. Used internally.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state_number</strong><span class="classifier">list</span></dt><dd><p>Successive state number arrays that can be used in loops and other
iterations, using standard state enumeration <em>by definition</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_index">
<code class="sig-name descname">state_number_index</code><span class="sig-paren">(</span><em class="sig-param">dims</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_number_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of a quantum state corresponding to state,
given a system with dimensions given by dims.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_index</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">6</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list</span></dt><dd><p>State number array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>The index of the state given by <cite>state</cite> in standard enumeration
ordering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_index_number">
<code class="sig-name descname">state_index_number</code><span class="sig-paren">(</span><em class="sig-param">dims</em>, <em class="sig-param">index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_index_number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_index_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a quantum number representation given a state index, for a system
of composite structure defined by dims.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_index_number</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 1, 0]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>index</strong><span class="classifier">integer</span></dt><dd><p>The index of the state in standard enumeration ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">list</span></dt><dd><p>The state number array corresponding to index <cite>index</cite> in standard
enumeration ordering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_qobj">
<code class="sig-name descname">state_number_qobj</code><span class="sig-paren">(</span><em class="sig-param">dims</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_number_qobj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_qobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Qobj representation of a quantum state specified by the state
array <cite>state</cite>.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_qobj</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list</span></dt><dd><p>State number array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>state</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj.qobj</span></code></span></dt><dd><p>The state as a <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj.qobj</span></code> instance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.states.thermal_dm">
<code class="sig-name descname">thermal_dm</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">n</em>, <em class="sig-param">method='operator'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#thermal_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix for a thermal state of n particles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>n</strong><span class="classifier">float</span></dt><dd><p>Expectation value for number of particles in thermal state.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘operator’, ‘analytic’}</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">string</span></code> that sets the method used to generate the
thermal state probabilities</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Thermal state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘operator’ method (default) generates
the thermal state using the truncated number operator <code class="docutils literal notranslate"><span class="pre">num(N)</span></code>. This
is the method that should be used in computations. The
‘analytic’ method uses the analytic coefficients derived in
an infinite Hilbert space. The analytic form is not necessarily normalized,
if truncated too aggressively.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.51612903  0.          0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.25806452  0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.12903226  0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.06451613  0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.          0.03225806]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;analytic&#39;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.5      0.       0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.25     0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.125    0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.0625   0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.       0.03125]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.zero_ket">
<code class="sig-name descname">zero_ket</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#zero_ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.zero_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the zero ket vector with shape Nx1 and
dimensions <cite>dims</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Hilbert space dimensionality</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Optional dimensions if ket corresponds to
a composite Hilbert space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>zero_ket</strong><span class="classifier">qobj</span></dt><dd><p>Zero ket on given Hilbert space.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.operators">
<span id="quantum-operators"></span><h3>Quantum Operators<a class="headerlink" href="#module-qutip.operators" title="Permalink to this headline">¶</a></h3>
<p>This module contains functions for generating Qobj representation of a variety
of commonly occuring quantum operators.</p>
<dl class="function">
<dt id="qutip.operators.charge">
<code class="sig-name descname">charge</code><span class="sig-paren">(</span><em class="sig-param">Nmax</em>, <em class="sig-param">Nmin=None</em>, <em class="sig-param">frac=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the diagonal charge operator over charge states
from Nmin to Nmax.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Nmax</strong><span class="classifier">int</span></dt><dd><p>Maximum charge state to consider.</p>
</dd>
<dt><strong>Nmin</strong><span class="classifier">int (default = -Nmax)</span></dt><dd><p>Lowest charge state to consider.</p>
</dd>
<dt><strong>frac</strong><span class="classifier">float (default = 1)</span></dt><dd><p>Specify fractional charge if needed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C</strong><span class="classifier">Qobj</span></dt><dd><p>Charge operator over [Nmin,Nmax].</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.commutator">
<code class="sig-name descname">commutator</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em>, <em class="sig-param">kind='normal'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#commutator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.commutator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the commutator of kind <cite>kind</cite> (normal, anti) of the
two operators A and B.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.create">
<code class="sig-name descname">create</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation (raising) operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Qobj for raising operator.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">create</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 1.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  1.41421356+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.73205081+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.destroy">
<code class="sig-name descname">destroy</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#destroy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Destruction (lowering) operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Qobj for lowering operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">destroy</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  1.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.41421356+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  1.73205081+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.displace">
<code class="sig-name descname">displace</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">alpha</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#displace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.displace" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode displacement operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float/complex</span></dt><dd><p>Displacement amplitude.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Displacement operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">displace</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.96923323+0.j -0.24230859+0.j  0.04282883+0.j -0.00626025+0.j]</span>
<span class="go"> [ 0.24230859+0.j  0.90866411+0.j -0.33183303+0.j  0.07418172+0.j]</span>
<span class="go"> [ 0.04282883+0.j  0.33183303+0.j  0.84809499+0.j -0.41083747+0.j]</span>
<span class="go"> [ 0.00626025+0.j  0.07418172+0.j  0.41083747+0.j  0.90866411+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.enr_destroy">
<code class="sig-name descname">enr_destroy</code><span class="sig-paren">(</span><em class="sig-param">dims</em>, <em class="sig-param">excitations</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#enr_destroy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.enr_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate annilation operators for modes in a excitation-number-restricted
state space. For example, consider a system consisting of 4 modes, each
with 5 states. The total hilbert space size is 5**4 = 625. If we are
only interested in states that contain up to 2 excitations, we only need
to include states such as</p>
<blockquote>
<div><p>(0, 0, 0, 0)
(0, 0, 0, 1)
(0, 0, 0, 2)
(0, 0, 1, 0)
(0, 0, 1, 1)
(0, 0, 2, 0)
…</p>
</div></blockquote>
<p>This function creates annihilation operators for the 4 modes that act
within this state space:</p>
<blockquote>
<div><p>a1, a2, a3, a4 = enr_destroy([5, 5, 5, 5], excitations=2)</p>
</div></blockquote>
<p>From this point onwards, the annihiltion operators a1, …, a4 can be
used to setup a Hamiltonian, collapse operators and expectation-value
operators, etc., following the usual pattern.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a_ops</strong><span class="classifier">list of qobj</span></dt><dd><p>A list of annihilation operators for each mode in the composite
quantum system described by dims.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.enr_identity">
<code class="sig-name descname">enr_identity</code><span class="sig-paren">(</span><em class="sig-param">dims</em>, <em class="sig-param">excitations</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#enr_identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.enr_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the identity operator for the excitation-number restricted
state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments. See the
docstring for enr_fock for a more detailed description of these arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list of integers</span></dt><dd><p>The state in the number basis representation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p>A Qobj instance that represent the identity operator in the
exication-number-restricted state space defined by <cite>dims</cite> and
<cite>exciations</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.jmat">
<code class="sig-name descname">jmat</code><span class="sig-paren">(</span><em class="sig-param">j</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#jmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.jmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Higher-order spin operators:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
<dt><strong>args</strong><span class="classifier">str</span></dt><dd><p>Which operator to return ‘x’,’y’,’z’,’+’,’-‘.
If no args given, then output is [‘x’,’y’,’z’]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>jmat</strong><span class="classifier">qobj / ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> for requested spin operator(s).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If no ‘args’ input, then returns array of [‘x’,’y’,’z’] operators.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jmat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          0.70710678  0.        ]</span>
<span class="go"> [ 0.70710678  0.          0.70710678]</span>
<span class="go"> [ 0.          0.70710678  0.        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j          0.-0.70710678j  0.+0.j        ]</span>
<span class="go"> [ 0.+0.70710678j  0.+0.j          0.-0.70710678j]</span>
<span class="go"> [ 0.+0.j          0.+0.70710678j  0.+0.j        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  0.  0.]</span>
<span class="go"> [ 0.  0. -1.]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.num">
<code class="sig-name descname">num</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#num"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.num" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object for number operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>The dimension of the Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>oper: qobj</dt><dd><p>Qobj for number operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[0 0 0 0]</span>
<span class="go"> [0 1 0 0]</span>
<span class="go"> [0 0 2 0]</span>
<span class="go"> [0 0 0 3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qeye">
<code class="sig-name descname">qeye</code><span class="sig-paren">(</span><em class="sig-param">N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qeye"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qeye" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int or list of ints</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<code class="docutils literal notranslate"><span class="pre">dims</span></code> property of the new Qobj are set to this list.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Identity operator Qobj.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.identity">
<code class="sig-name descname">identity</code><span class="sig-paren">(</span><em class="sig-param">N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator. Alternative name to <a class="reference internal" href="#qutip.operators.qeye" title="qutip.operators.qeye"><code class="xref py py-func docutils literal notranslate"><span class="pre">qeye</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int or list of ints</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<code class="docutils literal notranslate"><span class="pre">dims</span></code> property of the new Qobj are set to this list.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Identity operator Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.momentum">
<code class="sig-name descname">momentum</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#momentum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.momentum" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum operator p=-1j/sqrt(2)*(a-a.dag())</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Momentum operator as Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.phase">
<code class="sig-name descname">phase</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">phi0=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Pegg-Barnett phase operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>phi0</strong><span class="classifier">float</span></dt><dd><p>Reference phase.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Phase operator with respect to reference phase.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.position">
<code class="sig-name descname">position</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Position operator x=1/sqrt(2)*(a+a.dag())</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Position operator as Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qdiags">
<code class="sig-name descname">qdiags</code><span class="sig-paren">(</span><em class="sig-param">diagonals</em>, <em class="sig-param">offsets</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">shape=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qdiags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qdiags" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an operator from an array of diagonals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>diagonals</strong><span class="classifier">sequence of array_like</span></dt><dd><p>Array of elements to place along the selected diagonals.</p>
</dd>
<dt><strong>offsets</strong><span class="classifier">sequence of ints</span></dt><dd><dl class="simple">
<dt>Sequence for diagonals to be set:</dt><dd><ul class="simple">
<li><p>k=0 main diagonal</p></li>
<li><p>k&gt;0 kth upper diagonal</p></li>
<li><p>k&lt;0 kth lower diagonal</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>dims</strong><span class="classifier">list, optional</span></dt><dd><p>Dimensions for operator</p>
</dd>
<dt><strong>shape</strong><span class="classifier">list, tuple, optional</span></dt><dd><p>Shape of operator.  If omitted, a square operator large enough
to contain the diagonals is generated.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.diags</span></code></dt><dd><p>for usage information.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function requires SciPy 0.11+.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qdiags</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          1.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          1.41421356  0.        ]</span>
<span class="go"> [ 0.          0.          0.          1.73205081]</span>
<span class="go"> [ 0.          0.          0.          0.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qutrit_ops">
<code class="sig-name descname">qutrit_ops</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qutrit_ops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qutrit_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>opers: array</dt><dd><p><cite>array</cite> of qutrit operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qzero">
<code class="sig-name descname">qzero</code><span class="sig-paren">(</span><em class="sig-param">N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int or list of ints</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<code class="docutils literal notranslate"><span class="pre">dims</span></code> property of the new Qobj are set to this list.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qzero</strong><span class="classifier">qobj</span></dt><dd><p>Zero operator Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmam">
<code class="sig-name descname">sigmam</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmam" title="Permalink to this definition">¶</a></dt>
<dd><p>Annihilation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmam</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmap">
<code class="sig-name descname">sigmap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmax">
<code class="sig-name descname">sigmax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-x operator</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmax</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmay">
<code class="sig-name descname">sigmay</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmay" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-y operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmay</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.-1.j]</span>
<span class="go"> [ 0.+1.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmaz">
<code class="sig-name descname">sigmaz</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmaz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmaz" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-z operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.]</span>
<span class="go"> [ 0. -1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jx">
<code class="sig-name descname">spin_Jx</code><span class="sig-paren">(</span><em class="sig-param">j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jx" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j x operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jy">
<code class="sig-name descname">spin_Jy</code><span class="sig-paren">(</span><em class="sig-param">j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jy" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j y operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jz">
<code class="sig-name descname">spin_Jz</code><span class="sig-paren">(</span><em class="sig-param">j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jz" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j z operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jm">
<code class="sig-name descname">spin_Jm</code><span class="sig-paren">(</span><em class="sig-param">j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jm" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j annihilation operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jp">
<code class="sig-name descname">spin_Jp</code><span class="sig-paren">(</span><em class="sig-param">j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jp" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j creation operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.squeeze">
<code class="sig-name descname">squeeze</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">z</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Squeezing operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of hilbert space.</p>
</dd>
<dt><strong>z</strong><span class="classifier">float/complex</span></dt><dd><p>Squeezing parameter.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt><dd><p>Squeezing operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squeeze</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.98441565+0.j  0.00000000+0.j  0.17585742+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.95349007+0.j  0.00000000+0.j  0.30142443+0.j]</span>
<span class="go"> [-0.17585742+0.j  0.00000000+0.j  0.98441565+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.30142443+0.j  0.00000000+0.j  0.95349007+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.squeezing">
<code class="sig-name descname">squeezing</code><span class="sig-paren">(</span><em class="sig-param">a1</em>, <em class="sig-param">a2</em>, <em class="sig-param">z</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#squeezing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.squeezing" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized squeezing operator.</p>
<div class="math notranslate nohighlight">
\[S(z) = \exp\left(\frac{1}{2}\left(z^*a_1a_2
- za_1^\dagger a_2^\dagger\right)\right)\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a1</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt><dd><p>Operator 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt><dd><p>Operator 2.</p>
</dd>
<dt><strong>z</strong><span class="classifier">float/complex</span></dt><dd><p>Squeezing parameter.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt><dd><p>Squeezing operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.tunneling">
<code class="sig-name descname">tunneling</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">m=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#tunneling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.tunneling" title="Permalink to this definition">¶</a></dt>
<dd><p>Tunneling operator with elements of the form
<span class="math notranslate nohighlight">\(\sum |N&gt;&lt;N+m| + |N+m&gt;&lt;N|\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>m</strong><span class="classifier">int (default = 1)</span></dt><dd><p>Number of excitations in tunneling event.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">Qobj</span></dt><dd><p>Tunneling operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.2.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.random_objects">
<span id="random-operators-and-states"></span><span id="functions-rand"></span><h3>Random Operators and States<a class="headerlink" href="#module-qutip.random_objects" title="Permalink to this headline">¶</a></h3>
<p>This module is a collection of random state and operator generators.
The sparsity of the ouput Qobj’s is controlled by varing the
<cite>density</cite> parameter.</p>
<dl class="function">
<dt id="qutip.random_objects.rand_dm">
<code class="sig-name descname">rand_dm</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">density=0.75</em>, <em class="sig-param">pure=False</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int, ndarray, list</span></dt><dd><p>If int, then shape of output operator. If list/ndarray then eigenvalues
of generated density matrix.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Density between [0,1] of output density matrix.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>NxN density matrix quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For small density matrices., choosing a low density will result in an error
as no diagonal elements will be generated such that <span class="math notranslate nohighlight">\(Tr(\rho)=1\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_dm_ginibre">
<code class="sig-name descname">rand_dm_ginibre</code><span class="sig-paren">(</span><em class="sig-param">N=2</em>, <em class="sig-param">rank=None</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_dm_ginibre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_dm_ginibre" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Ginibre random density operator of dimension
<code class="docutils literal notranslate"><span class="pre">dim</span></code> and rank <code class="docutils literal notranslate"><span class="pre">rank</span></code> by using the algorithm of
<a class="reference internal" href="../biblio.html#bcsz08" id="id34"><span>[BCSZ08]</span></a>. If <code class="docutils literal notranslate"><span class="pre">rank</span></code> is <cite>None</cite>, a full-rank
(Hilbert-Schmidt ensemble) random density operator will be
returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of the density operator to be returned.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int or None</span></dt><dd><p>Rank of the sampled density operator. If None, a full-rank
density operator is generated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>An N × N density operator sampled from the Ginibre
or Hilbert-Schmidt distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_dm_hs">
<code class="sig-name descname">rand_dm_hs</code><span class="sig-paren">(</span><em class="sig-param">N=2</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_dm_hs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_dm_hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Hilbert-Schmidt random density operator of dimension
<code class="docutils literal notranslate"><span class="pre">dim</span></code> and rank <code class="docutils literal notranslate"><span class="pre">rank</span></code> by using the algorithm of
<a class="reference internal" href="../biblio.html#bcsz08" id="id35"><span>[BCSZ08]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of the density operator to be returned.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>A dim × dim density operator sampled from the Ginibre
or Hilbert-Schmidt distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_herm">
<code class="sig-name descname">rand_herm</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">density=0.75</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">pos_def=False</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_herm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_herm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse Hermitian quantum object.</p>
<p>If ‘N’ is an integer, uses <span class="math notranslate nohighlight">\(H=0.5*(X+X^{+})\)</span> where <span class="math notranslate nohighlight">\(X\)</span> is
a randomly generated quantum operator with a given <cite>density</cite>. Else uses
complex Jacobi rotations when ‘N’ is given by an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int, list/ndarray</span></dt><dd><p>If int, then shape of output operator. If list/ndarray then eigenvalues
of generated operator.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Density between [0,1] of output Hermitian operator.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
<dt><strong>pos_def</strong><span class="classifier">bool (default=False)</span></dt><dd><p>Return a positive semi-definite matrix (by diagonal dominance).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>NxN Hermitian quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_ket">
<code class="sig-name descname">rand_ket</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">density=1</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random Nx1 sparse ket vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of rows for output quantum operator.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Density between [0,1] of output ket state.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Left-dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Nx1 ket state quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_ket_haar">
<code class="sig-name descname">rand_ket_haar</code><span class="sig-paren">(</span><em class="sig-param">N=2</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_ket_haar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_ket_haar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Haar random pure state of dimension <code class="docutils literal notranslate"><span class="pre">dim</span></code> by
applying a Haar random unitary to a fixed pure state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of the state vector to be returned.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of ints, or None</span></dt><dd><p>Left-dimensions of the resultant quantum object.
If None, [N] is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>psi</strong><span class="classifier">Qobj</span></dt><dd><p>A random state vector drawn from the Haar measure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_unitary">
<code class="sig-name descname">rand_unitary</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">density=0.75</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse unitary quantum object.</p>
<p>Uses <span class="math notranslate nohighlight">\(\exp(-iH)\)</span> where H is a randomly generated
Hermitian operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Shape of output quantum operator.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Density between [0,1] of output Unitary operator.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>NxN Unitary quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_unitary_haar">
<code class="sig-name descname">rand_unitary_haar</code><span class="sig-paren">(</span><em class="sig-param">N=2</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_unitary_haar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_unitary_haar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Haar random unitary matrix of dimension
<code class="docutils literal notranslate"><span class="pre">dim</span></code>, using the algorithm of <a class="reference internal" href="../biblio.html#mez07" id="id36"><span>[Mez07]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of the unitary to be returned.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of lists of int, or None</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>Unitary of dims <code class="docutils literal notranslate"><span class="pre">[[dim],</span> <span class="pre">[dim]]</span></code> drawn from the Haar
measure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_super">
<code class="sig-name descname">rand_super</code><span class="sig-paren">(</span><em class="sig-param">N=5</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_super"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randomly drawn superoperator acting on operators acting on
N dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Square root of the dimension of the superoperator to be returned.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[[N],[N]], [[N],[N]]].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_super_bcsz">
<code class="sig-name descname">rand_super_bcsz</code><span class="sig-paren">(</span><em class="sig-param">N=2</em>, <em class="sig-param">enforce_tp=True</em>, <em class="sig-param">rank=None</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_super_bcsz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_super_bcsz" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random superoperator drawn from the Bruzda
et al ensemble for CPTP maps <a class="reference internal" href="../biblio.html#bcsz08" id="id37"><span>[BCSZ08]</span></a>. Note that due to
finite numerical precision, for ranks less than full-rank,
zero eigenvalues may become slightly negative, such that the
returned operator is not actually completely positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Square root of the dimension of the superoperator to be returned.</p>
</dd>
<dt><strong>enforce_tp</strong><span class="classifier">bool</span></dt><dd><p>If True, the trace-preserving condition of <a class="reference internal" href="../biblio.html#bcsz08" id="id38"><span>[BCSZ08]</span></a> is enforced;
otherwise only complete positivity is enforced.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int or None</span></dt><dd><p>Rank of the sampled superoperator. If None, a full-rank
superoperator is generated.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[[N],[N]], [[N],[N]]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>A superoperator acting on vectorized dim × dim density operators,
sampled from the BCSZ distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.three_level_atom">
<span id="three-level-atoms"></span><h3>Three-Level Atoms<a class="headerlink" href="#module-qutip.three_level_atom" title="Permalink to this headline">¶</a></h3>
<p>This module provides functions that are useful for simulating the
three level atom with QuTiP.  A three level atom (qutrit) has three states,
which are linked by dipole transitions so that 1 &lt;-&gt; 2 &lt;-&gt; 3.
Depending on there relative energies they are in the ladder, lambda or
vee configuration. The structure of the relevant operators is the same
for any of the three configurations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ladder</span><span class="p">:</span>          <span class="n">Lambda</span><span class="p">:</span>                 <span class="n">Vee</span><span class="p">:</span>
                            <span class="o">|</span><span class="n">two</span><span class="o">&gt;</span>                       <span class="o">|</span><span class="n">three</span><span class="o">&gt;</span>
  <span class="o">-------|</span><span class="n">three</span><span class="o">&gt;</span>           <span class="o">-------</span>                      <span class="o">-------</span>
     <span class="o">|</span>                       <span class="o">/</span> \             <span class="o">|</span><span class="n">one</span><span class="o">&gt;</span>         <span class="o">/</span>
     <span class="o">|</span>                      <span class="o">/</span>   \           <span class="o">-------</span>       <span class="o">/</span>
     <span class="o">|</span>                     <span class="o">/</span>     \             \         <span class="o">/</span>
  <span class="o">-------|</span><span class="n">two</span><span class="o">&gt;</span>            <span class="o">/</span>       \             \       <span class="o">/</span>
     <span class="o">|</span>                   <span class="o">/</span>         \             \     <span class="o">/</span>
     <span class="o">|</span>                  <span class="o">/</span>           \             \   <span class="o">/</span>
     <span class="o">|</span>                 <span class="o">/</span>        <span class="o">--------</span>           \ <span class="o">/</span>
  <span class="o">-------|</span><span class="n">one</span><span class="o">&gt;</span>      <span class="o">-------</span>      <span class="o">|</span><span class="n">three</span><span class="o">&gt;</span>         <span class="o">-------</span>
                     <span class="o">|</span><span class="n">one</span><span class="o">&gt;</span>                       <span class="o">|</span><span class="n">two</span><span class="o">&gt;</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>The naming of qutip operators follows the convention in <a class="reference internal" href="#r0be8dcf25d86-1" id="id39"><span>[R0be8dcf25d86-1]</span></a> .</p>
<dl class="citation">
<dt class="label" id="r0be8dcf25d86-1"><span class="brackets"><a class="fn-backref" href="#id39">R0be8dcf25d86-1</a></span></dt>
<dd><p>Shore, B. W., “The Theory of Coherent Atomic Excitation”,
Wiley, 1990.</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Contributed by Markus Baden, Oct. 07, 2011</p>
</div>
<dl class="function">
<dt id="qutip.three_level_atom.three_level_basis">
<code class="sig-name descname">three_level_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/three_level_atom.html#three_level_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.three_level_atom.three_level_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level atom.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>states</strong><span class="classifier">array</span></dt><dd><p><cite>array</cite> of three level atom basis vectors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.three_level_atom.three_level_ops">
<code class="sig-name descname">three_level_ops</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/three_level_atom.html#three_level_ops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.three_level_atom.three_level_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ops</strong><span class="classifier">array</span></dt><dd><p><cite>array</cite> of three level operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.superoperator">
<span id="superoperators-and-liouvillians"></span><h3>Superoperators and Liouvillians<a class="headerlink" href="#module-qutip.superoperator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.superoperator.operator_to_vector">
<code class="sig-name descname">operator_to_vector</code><span class="sig-paren">(</span><em class="sig-param">op</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#operator_to_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.operator_to_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a vector representation of a quantum operator given
the matrix representation.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.vector_to_operator">
<code class="sig-name descname">vector_to_operator</code><span class="sig-paren">(</span><em class="sig-param">op</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#vector_to_operator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.vector_to_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a matrix representation given a quantum operator in
vector form.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.liouvillian">
<code class="sig-name descname">liouvillian</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">c_ops=[]</em>, <em class="sig-param">data_only=False</em>, <em class="sig-param">chi=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#liouvillian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.liouvillian" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembles the Liouvillian superoperator from a Hamiltonian
and a <code class="docutils literal notranslate"><span class="pre">list</span></code> of collapse operators. Like liouvillian, but with an
experimental implementation which avoids creating extra Qobj instances,
which can be advantageous for large systems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">array_like of Qobj or QobjEvo</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of collapse operators.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>L</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Liouvillian superoperator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.spost">
<code class="sig-name descname">spost</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#spost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.spost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from post-multiplication by operator A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for post multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>super</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Superoperator formed from input qauntum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.spre">
<code class="sig-name descname">spre</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#spre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.spre" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for pre-multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>super :Qobj or QobjEvo</dt><dd><p>Superoperator formed from input quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.sprepost">
<code class="sig-name descname">sprepost</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#sprepost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.sprepost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A and post-
multiplication of operator B.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for pre-multiplication.</p>
</dd>
<dt><strong>B</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for post-multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>super</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Superoperator formed from input quantum objects.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.lindblad_dissipator">
<code class="sig-name descname">lindblad_dissipator</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b=None</em>, <em class="sig-param">data_only=False</em>, <em class="sig-param">chi=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#lindblad_dissipator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.lindblad_dissipator" title="Permalink to this definition">¶</a></dt>
<dd><p>Lindblad dissipator (generalized) for a single pair of collapse operators
(a, b), or for a single collapse operator (a) when b is not specified:</p>
<div class="math notranslate nohighlight">
\[\mathcal{D}[a,b]\rho = a \rho b^\dagger -
\frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Left part of collapse operator.</p>
</dd>
<dt><strong>b</strong><span class="classifier">Qobj or QobjEvo (optional)</span></dt><dd><p>Right part of collapse operator. If not specified, b defaults to a.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>D</strong><span class="classifier">qobj, QobjEvo</span></dt><dd><p>Lindblad dissipator superoperator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.superop_reps">
<span id="superoperator-representations"></span><h3>Superoperator Representations<a class="headerlink" href="#module-qutip.superop_reps" title="Permalink to this headline">¶</a></h3>
<p>This module implements transformations between superoperator representations,
including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.</p>
<dl class="function">
<dt id="qutip.superop_reps.to_choi">
<code class="sig-name descname">to_choi</code><span class="sig-paren">(</span><em class="sig-param">q_oper</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superop_reps.html#to_choi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_choi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the Choi representation,
such that the trace of the returned operator is equal to the dimension
of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to Choi representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_choi(A)</span> <span class="pre">==</span> <span class="pre">to_choi(sprepost(A,</span> <span class="pre">A.dag()))</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>choi</strong><span class="classifier">Qobj</span></dt><dd><p>A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">choi.superrep</span> <span class="pre">==</span> <span class="pre">&quot;choi&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError: if the given quantum object is not a map, or cannot be converted</dt><dd><p>to Choi representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.superop_reps.to_super">
<code class="sig-name descname">to_super</code><span class="sig-paren">(</span><em class="sig-param">q_oper</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superop_reps.html#to_super"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the supermatrix (Liouville)
representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to supermatrix representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_super(A)</span> <span class="pre">==</span> <span class="pre">sprepost(A,</span> <span class="pre">A.dag())</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>superop</strong><span class="classifier">Qobj</span></dt><dd><p>A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">superop.superrep</span> <span class="pre">==</span> <span class="pre">&quot;super&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the given quantum object is not a map, or cannot be converted
to supermatrix representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.superop_reps.to_kraus">
<code class="sig-name descname">to_kraus</code><span class="sig-paren">(</span><em class="sig-param">q_oper</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superop_reps.html#to_kraus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_kraus" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to a list of quantum objects,
each representing an operator in the Kraus decomposition of the given map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to Kraus representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_kraus(A)</span> <span class="pre">==</span> <span class="pre">to_kraus(sprepost(A,</span> <span class="pre">A.dag()))</span> <span class="pre">==</span> <span class="pre">[A]</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>kraus_ops</strong><span class="classifier">list of Qobj</span></dt><dd><p>A list of quantum objects, each representing a Kraus operator in the
decomposition of <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError: if the given quantum object is not a map, or cannot be</dt><dd><p>decomposed into Kraus operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="functions-acting-on-states-and-operators">
<h2>Functions acting on states and operators<a class="headerlink" href="#functions-acting-on-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.expect">
<span id="expectation-values"></span><h3>Expectation Values<a class="headerlink" href="#module-qutip.expect" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.expect.expect">
<code class="sig-name descname">expect</code><span class="sig-paren">(</span><em class="sig-param">oper</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/expect.html#expect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.expect.expect" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value for operator(s) and state(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj/array-like</span></dt><dd><p>A single or a <cite>list</cite> or operators for expectation value.</p>
</dd>
<dt><strong>state</strong><span class="classifier">qobj/array-like</span></dt><dd><p>A single or a <cite>list</cite> of quantum states or density matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>expt</strong><span class="classifier">float/complex/array-like</span></dt><dd><p>Expectation value.  <code class="docutils literal notranslate"><span class="pre">real</span></code> if <cite>oper</cite> is Hermitian, <code class="docutils literal notranslate"><span class="pre">complex</span></code>
otherwise. A (nested) array of expectaction values of state or operator
are arrays.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expect</span><span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">basis</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.expect.variance">
<code class="sig-name descname">variance</code><span class="sig-paren">(</span><em class="sig-param">oper</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/expect.html#variance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.expect.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Variance of an operator for the given state vector or density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Operator for expectation value.</p>
</dd>
<dt><strong>state</strong><span class="classifier">qobj/list</span></dt><dd><p>A single or <cite>list</cite> of quantum states or density matrices..</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>var</strong><span class="classifier">float</span></dt><dd><p>Variance of operator ‘oper’ for given state.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.tensor">
<span id="tensor"></span><h3>Tensor<a class="headerlink" href="#module-qutip.tensor" title="Permalink to this headline">¶</a></h3>
<p>Module for the creation of composite quantum objects via the tensor product.</p>
<dl class="function">
<dt id="qutip.tensor.tensor">
<code class="sig-name descname">tensor</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">array_like</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of quantum objects for tensor product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">qobj</span></dt><dd><p>A composite quantum object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">sigmax</span><span class="p">()])</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.super_tensor">
<code class="sig-name descname">super_tensor</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#super_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.super_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input superoperators, by tensoring
together the underlying Hilbert spaces on which each vectorized operator
acts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">array_like</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of quantum objects with <code class="docutils literal notranslate"><span class="pre">type=&quot;super&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">qobj</span></dt><dd><p>A composite quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.composite">
<code class="sig-name descname">composite</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#composite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.composite" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two or more operators, kets or bras, returns the Qobj
corresponding to a composite system over each argument.
For ordinary operators and vectors, this is the tensor product,
while for superoperators and vectorized operators, this is
the column-reshuffled tensor product.</p>
<p>If a mix of Qobjs supported on Hilbert and Liouville spaces
are passed in, the former are promoted. Ordinary operators
are assumed to be unitaries, and are promoted using <code class="docutils literal notranslate"><span class="pre">to_super</span></code>,
while kets and bras are promoted by taking their projectors and
using <code class="docutils literal notranslate"><span class="pre">operator_to_vector(ket2dm(arg))</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.tensor_contract">
<code class="sig-name descname">tensor_contract</code><span class="sig-paren">(</span><em class="sig-param">qobj</em>, <em class="sig-param">*pairs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#tensor_contract"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.tensor_contract" title="Permalink to this definition">¶</a></dt>
<dd><p>Contracts a qobj along one or more index pairs.
Note that this uses dense representations and thus
should <em>not</em> be used for very large Qobjs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">tuple</span></dt><dd><p>One or more tuples <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> indicating that the
<code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> dimensions of the original qobj
should be contracted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cqobj</strong><span class="classifier">Qobj</span></dt><dd><p>The original Qobj with all named index pairs contracted
away.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.partial_transpose">
<span id="partial-transpose"></span><h3>Partial Transpose<a class="headerlink" href="#module-qutip.partial_transpose" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.partial_transpose.partial_transpose">
<code class="sig-name descname">partial_transpose</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">mask</em>, <em class="sig-param">method='dense'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/partial_transpose.html#partial_transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.partial_transpose.partial_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the partial transpose of a Qobj instance <cite>rho</cite>,
where <cite>mask</cite> is an array/list with length that equals
the number of components of <cite>rho</cite> (that is, the length of
<cite>rho.dims[0]</cite>), and the values in <cite>mask</cite> indicates whether
or not the corresponding subsystem is to be transposed.
The elements in <cite>mask</cite> can be boolean or integers <cite>0</cite> or <cite>1</cite>,
where <cite>True</cite>/<cite>1</cite> indicates that the corresponding subsystem
should be tranposed.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>A density matrix.</p>
</dd>
<dt><strong>mask</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>A mask that selects which subsystems should be transposed.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>choice of method, <cite>dense</cite> or <cite>sparse</cite>. The default method
is <cite>dense</cite>. The <cite>sparse</cite> implementation can be faster for
large and sparse systems (hundreds of quantum states).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>rho_pr: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></dt><dd><p>A density matrix with the selected subsystems transposed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.entropy">
<span id="entropy-functions"></span><span id="functions-entropy"></span><h3>Entropy Functions<a class="headerlink" href="#module-qutip.entropy" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.entropy.concurrence">
<code class="sig-name descname">concurrence</code><span class="sig-paren">(</span><em class="sig-param">rho</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#concurrence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.concurrence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the concurrence entanglement measure for a two-qubit state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Ket, bra, or density matrix for a two-qubit state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>concur</strong><span class="classifier">float</span></dt><dd><p>Concurrence</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8ba8a4d22c3a-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://en.wikipedia.org/wiki/Concurrence_(quantum_computing">http://en.wikipedia.org/wiki/Concurrence_(quantum_computing</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_conditional">
<code class="sig-name descname">entropy_conditional</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">selB</em>, <em class="sig-param">base=2.718281828459045</em>, <em class="sig-param">sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_conditional"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_conditional" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the conditional entropy <span class="math notranslate nohighlight">\(S(A|B)=S(A,B)-S(B)\)</span>
of a selected density matrix component.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix of composite object</p>
</dd>
<dt><strong>selB</strong><span class="classifier">int/list</span></dt><dd><p>Selected components for density matrix B</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False,True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ent_cond</strong><span class="classifier">float</span></dt><dd><p>Value of conditional entropy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_linear">
<code class="sig-name descname">entropy_linear</code><span class="sig-paren">(</span><em class="sig-param">rho</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear entropy of a density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>sensity matrix or ket/bra vector.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropy</strong><span class="classifier">float</span></dt><dd><p>Linear entropy of rho.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_linear</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_mutual">
<code class="sig-name descname">entropy_mutual</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">selA</em>, <em class="sig-param">selB</em>, <em class="sig-param">base=2.718281828459045</em>, <em class="sig-param">sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_mutual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_mutual" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mutual information S(A:B) between selection
components of a system density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix for composite quantum systems</p>
</dd>
<dt><strong>selA</strong><span class="classifier">int/list</span></dt><dd><p><cite>int</cite> or <cite>list</cite> of first selected density matrix components.</p>
</dd>
<dt><strong>selB</strong><span class="classifier">int/list</span></dt><dd><p><cite>int</cite> or <cite>list</cite> of second selected density matrix components.</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False,True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ent_mut</strong><span class="classifier">float</span></dt><dd><p>Mutual information between selected components.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_vn">
<code class="sig-name descname">entropy_vn</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">base=2.718281828459045</em>, <em class="sig-param">sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_vn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_vn" title="Permalink to this definition">¶</a></dt>
<dd><p>Von-Neumann entropy of density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix.</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False,True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropy</strong><span class="classifier">float</span></dt><dd><p>Von-Neumann entropy of <cite>rho</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_vn</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.metrics">
<span id="density-matrix-metrics"></span><h3>Density Matrix Metrics<a class="headerlink" href="#module-qutip.metrics" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of functions for calculating metrics
(distance measures) between states and operators.</p>
<dl class="function">
<dt id="qutip.metrics.fidelity">
<code class="sig-name descname">fidelity</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the fidelity (pseudo-metric) between two density matrices.
See: Nielsen &amp; Chuang, “Quantum Computation and Quantum Information”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fid</strong><span class="classifier">float</span></dt><dd><p>Fidelity pseudo-metric between A and B.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">0.24104350624628332</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.tracedist">
<code class="sig-name descname">tracedist</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em>, <em class="sig-param">sparse=False</em>, <em class="sig-param">tol=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#tracedist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.tracedist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the trace distance between two density matrices..
See: Nielsen &amp; Chuang, “Quantum Computation and Quantum Information”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse eigensolver, if used. (0=Machine precision)</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False, True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tracedist</strong><span class="classifier">float</span></dt><dd><p>Trace distance between A and B.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tracedist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">0.9705143161472971</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.bures_dist">
<code class="sig-name descname">bures_dist</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#bures_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.bures_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bures distance between two density matrices A &amp; B.</p>
<p>The Bures distance ranges from 0, for states with unit fidelity,
to sqrt(2).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dist</strong><span class="classifier">float</span></dt><dd><p>Bures distance between density matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.bures_angle">
<code class="sig-name descname">bures_angle</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#bures_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.bures_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bures Angle between two density matrices A &amp; B.</p>
<p>The Bures angle ranges from 0, for states with unit fidelity, to pi/2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Bures angle between density matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.hilbert_dist">
<code class="sig-name descname">hilbert_dist</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#hilbert_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.hilbert_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hilbert-Schmidt distance between two density matrices A &amp; B.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dist</strong><span class="classifier">float</span></dt><dd><p>Hilbert-Schmidt distance between density matrices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.average_gate_fidelity">
<code class="sig-name descname">average_gate_fidelity</code><span class="sig-paren">(</span><em class="sig-param">oper</em>, <em class="sig-param">target=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#average_gate_fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.average_gate_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a Qobj representing the supermatrix form of a map, returns the
average gate fidelity (pseudo-metric) of that map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum object representing a superoperator.</p>
</dd>
<dt><strong>target</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum object representing the target unitary; the inverse
is applied before evaluating the fidelity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fid</strong><span class="classifier">float</span></dt><dd><p>Fidelity pseudo-metric between A and the identity superoperator,
or between A and the target superunitary.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.process_fidelity">
<code class="sig-name descname">process_fidelity</code><span class="sig-paren">(</span><em class="sig-param">U1</em>, <em class="sig-param">U2</em>, <em class="sig-param">normalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#process_fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.process_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the process fidelity given two process operators.</p>
</dd></dl>

</div>
<div class="section" id="continuous-variables">
<h3>Continuous Variables<a class="headerlink" href="#continuous-variables" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-qutip.continuous_variables"></span><p>This module contains a collection functions for calculating continuous variable
quantities from fock-basis representation of the state of multi-mode fields.</p>
<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix">
<code class="sig-name descname">correlation_matrix</code><span class="sig-paren">(</span><em class="sig-param">basis</em>, <em class="sig-param">rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#correlation_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math notranslate nohighlight">\(\{a\}_n\)</span>, calculate the correlation
matrix:</p>
<div class="math notranslate nohighlight">
\[C_{mn} = \langle a_m a_n \rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">list</span></dt><dd><p>List of operators that defines the basis for the correlation matrix.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the correlation matrix. If
<cite>rho</cite> is <cite>None</cite>, then a matrix of correlation matrix operators is
returned instead of expectation values of those operators.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional <em>array</em> of correlation values or operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.covariance_matrix">
<code class="sig-name descname">covariance_matrix</code><span class="sig-paren">(</span><em class="sig-param">basis</em>, <em class="sig-param">rho</em>, <em class="sig-param">symmetrized=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#covariance_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math notranslate nohighlight">\(\{a\}_n\)</span>, calculate the covariance
matrix:</p>
<div class="math notranslate nohighlight">
\[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<p>or, if of the optional argument <cite>symmetrized=False</cite>,</p>
<div class="math notranslate nohighlight">
\[V_{mn} = \langle a_m a_n\rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">list</span></dt><dd><p>List of operators that defines the basis for the covariance matrix.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
<dt><strong>symmetrized</strong><span class="classifier">bool {True, False}</span></dt><dd><p>Flag indicating whether the symmetrized (default) or non-symmetrized
correlation matrix is to be calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional array of covariance values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix_field">
<code class="sig-name descname">correlation_matrix_field</code><span class="sig-paren">(</span><em class="sig-param">a1</em>, <em class="sig-param">a2</em>, <em class="sig-param">rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#correlation_matrix_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the correlation matrix for given field operators <span class="math notranslate nohighlight">\(a_1\)</span> and
<span class="math notranslate nohighlight">\(a_2\)</span>. If a density matrix is given the expectation values are
calculated, otherwise a matrix with operators is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a1</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 2.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cov_mat</strong><span class="classifier">ndarray</span></dt><dd><p>Array of complex numbers or Qobj’s
A 2-dimensional <em>array</em> of covariance values, or, if rho=0, a matrix
of operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix_quadrature">
<code class="sig-name descname">correlation_matrix_quadrature</code><span class="sig-paren">(</span><em class="sig-param">a1</em>, <em class="sig-param">a2</em>, <em class="sig-param">rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#correlation_matrix_quadrature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_quadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quadrature correlation matrix with given field operators
<span class="math notranslate nohighlight">\(a_1\)</span> and <span class="math notranslate nohighlight">\(a_2\)</span>. If a density matrix is given the expectation
values are calculated, otherwise a matrix with operators is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a1</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 2.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>Array of complex numbers or Qobj’s
A 2-dimensional <em>array</em> of covariance values for the field quadratures,
or, if rho=0, a matrix of operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.wigner_covariance_matrix">
<code class="sig-name descname">wigner_covariance_matrix</code><span class="sig-paren">(</span><em class="sig-param">a1=None</em>, <em class="sig-param">a2=None</em>, <em class="sig-param">R=None</em>, <em class="sig-param">rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#wigner_covariance_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.wigner_covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Wigner covariance matrix
<span class="math notranslate nohighlight">\(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\)</span>, given
the quadrature correlation matrix
<span class="math notranslate nohighlight">\(R_{ij} = \langle R_{i} R_{j}\rangle -
\langle R_{i}\rangle \langle R_{j}\rangle\)</span>, where
<span class="math notranslate nohighlight">\(R = (q_1, p_1, q_2, p_2)^T\)</span> is the vector with quadrature operators
for the two modes.</p>
<p>Alternatively, if <cite>R = None</cite>, and if annihilation operators <cite>a1</cite> and <cite>a2</cite>
for the two modes are supplied instead, the quadrature correlation matrix
is constructed from the annihilation operators before then the covariance
matrix is calculated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a1</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 2.</p>
</dd>
<dt><strong>R</strong><span class="classifier">ndarray</span></dt><dd><p>The quadrature correlation matrix.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cov_mat</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional array of covariance values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.logarithmic_negativity">
<code class="sig-name descname">logarithmic_negativity</code><span class="sig-paren">(</span><em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#logarithmic_negativity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.logarithmic_negativity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the logarithmic negativity given a symmetrized covariance
matrix, see <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.continous_variables.covariance_matrix</span></code>. Note that
the two-mode field state that is described by <cite>V</cite> must be Gaussian for this
function to applicable.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>V</strong><span class="classifier"><em>2d array</em></span></dt><dd><p>The covariance matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>N</strong><span class="classifier">float</span></dt><dd><p>The logarithmic negativity for the two-mode Gaussian state
that is described by the the Wigner covariance matrix V.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="dynamics-and-time-evolution">
<h2>Dynamics and Time-Evolution<a class="headerlink" href="#dynamics-and-time-evolution" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.sesolve">
<span id="schrodinger-equation"></span><h3>Schrödinger Equation<a class="headerlink" href="#module-qutip.sesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the unitary Schrodinger equation.</p>
<dl class="function">
<dt id="qutip.sesolve.sesolve">
<code class="sig-name descname">sesolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">psi0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">e_ops=[]</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b2261cb9eb8&gt;</em>, <em class="sig-param">progress_bar=&lt;qutip.ui.progressbar.BaseProgressBar object at 0x2b2261cb9ef0&gt;</em>, <em class="sig-param">_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/sesolve.html#sesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.sesolve.sesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Schrodinger equation evolution of a state vector or unitary matrix
for a given Hamiltonian.</p>
<p>Evolve the state vector (<cite>psi0</cite>) using a given
Hamiltonian (<cite>H</cite>), by integrating the set of ordinary differential
equations that define the system. Alternatively evolve a unitary matrix in
solving the Schrodinger operator equation.</p>
<p>The output is either the state vector or unitary matrix at arbitrary points
in time (<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values. e_ops cannot be used in conjunction
with solving the Schrodinger operator equation</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobjevo</span></code>, <em>list</em>, <em>callable</em></span></dt><dd><p>system Hamiltonian as a Qobj, list of Qobj and coefficient, QobjEvo,
or a callback function for time-dependent Hamiltonians.
list format and options can be found in QobjEvo’s description.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>initial state vector (ket)
or initial unitary operator <cite>psi0 = U</cite></p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> / callback function</span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.
For list operator evolution, the overlapse is computed:</p>
<blockquote>
<div><p>tr(e_ops[i].dag()*op(t))</p>
</div></blockquote>
</dd>
<dt><strong>args</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>dictionary of parameters for time-dependent Hamiltonians</p>
</dd>
<dt><strong>options</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qdeoptions</span></code></span></dt><dd><p>with options for the ODE solver.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">BaseProgressBar</span></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>, or
an <em>array</em> or state vectors corresponding to the
times in <cite>tlist</cite> [if <cite>e_ops</cite> is an empty list], or
nothing if a callback function was given inplace of operators for
which to calculate the expectation values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.mesolve">
<span id="master-equation"></span><h3>Master Equation<a class="headerlink" href="#module-qutip.mesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the Lindblad master equation and von Neumann
equation.</p>
<dl class="function">
<dt id="qutip.mesolve.mesolve">
<code class="sig-name descname">mesolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">rho0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">c_ops=[]</em>, <em class="sig-param">e_ops=[]</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b225f643f98&gt;</em>, <em class="sig-param">progress_bar=&lt;qutip.ui.progressbar.BaseProgressBar object at 0x2b225f643fd0&gt;</em>, <em class="sig-param">_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/mesolve.html#mesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.mesolve.mesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Master equation evolution of a density matrix for a given Hamiltonian and
set of collapse operators, or a Liouvillian.</p>
<p>Evolve the state vector or density matrix (<cite>rho0</cite>) using a given
Hamiltonian (<cite>H</cite>) and an [optional] set of collapse operators
(<cite>c_ops</cite>), by integrating the set of ordinary differential equations
that define the system. In the absence of collapse operators the system is
evolved according to the unitary evolution of the Hamiltonian.</p>
<p>The output is either the state vector at arbitrary points in time
(<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values.</p>
<p>If either <cite>H</cite> or the Qobj elements in <cite>c_ops</cite> are superoperators, they
will be treated as direct contributions to the total system Liouvillian.
This allows to solve master equations that are not on standard Lindblad
form by passing a custom Liouvillian in place of either the <cite>H</cite> or <cite>c_ops</cite>
elements.</p>
<p><strong>Time-dependent operators</strong></p>
<p>For time-dependent problems, <cite>H</cite> and <cite>c_ops</cite> can be callback
functions that takes two arguments, time and <cite>args</cite>, and returns the
Hamiltonian or Liouvillian for the system at that point in time
(<em>callback format</em>).</p>
<p>Alternatively, <cite>H</cite> and <cite>c_ops</cite> can be a specified in a nested-list format
where each element in the list is a list of length 2, containing an
operator (<code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code>) at the first element and where the
second element is either a string (<em>list string format</em>), a callback
function (<em>list callback format</em>) that evaluates to the time-dependent
coefficient for the corresponding operator, or a NumPy array (<em>list
array format</em>) which specifies the value of the coefficient to the
corresponding operator for each value of t in tlist.</p>
<p><em>Examples</em></p>
<blockquote>
<div><p>H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]</p>
<p>H = [[H0, f0_t], [H1, f1_t]]</p>
<p>where f0_t and f1_t are python functions with signature f_t(t, args).</p>
<p>H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]</p>
</div></blockquote>
<p>In the <em>list string format</em> and <em>list callback format</em>, the string
expression and the callback function must evaluate to a real or complex
number (coefficient for the corresponding operator).</p>
<p>In all cases of time-dependent operators, <cite>args</cite> is a dictionary of
parameters that is used when evaluating operators. It is passed to the
callback functions as second argument.</p>
<p><strong>Additional options</strong></p>
<p>Additional options to mesolve can be set via the <cite>options</cite> argument, which
should be an instance of <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a>. Many ODE
integration options can be set this way, and the <cite>store_states</cite> and
<cite>store_final_state</cite> options can be used to store states even though
expectation values are requested via the <cite>e_ops</cite> argument.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If an element in the list-specification of the Hamiltonian or
the list of collapse operators are in superoperator form it will be
added to the total Liouvillian of the problem with out further
transformation. This allows for using mesolve for solving master
equations that are not on standard Lindblad form.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On using callback function: mesolve transforms all <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code>
objects to sparse matrices before handing the problem to the integrator
function. In order for your callback function to work correctly, pass
all <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> objects that are used in constructing the
Hamiltonian via args. mesolve will check for <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> in
<cite>args</cite> and handle the conversion to sparse matrices. All other
<code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> objects that are not passed via <cite>args</cite> will be
passed on to the integrator in scipy which will raise an NotImplemented
exception.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System Hamiltonian, or a callback function for time-dependent
Hamiltonians, or alternatively a system Liouvillian.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>single collapse operator, or list of collapse operators, or a list
of Liouvillian superoperators.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function single</span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>args</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Options</span></code></span></dt><dd><p>with options for the solver.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">BaseProgressBar</span></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code>, which contains
either an <em>array</em> <cite>result.expect</cite> of expectation values for the times
specified by <cite>tlist</cite>, or an <em>array</em> <cite>result.states</cite> of state vectors or
density matrices corresponding to the times in <cite>tlist</cite> [if <cite>e_ops</cite> is
an empty list], or nothing if a callback function was given in place of
operators for which to calculate the expectation values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.mcsolve">
<span id="monte-carlo-evolution"></span><h3>Monte Carlo Evolution<a class="headerlink" href="#module-qutip.mcsolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.mcsolve.mcsolve">
<code class="sig-name descname">mcsolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">psi0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">c_ops=[]</em>, <em class="sig-param">e_ops=[]</em>, <em class="sig-param">ntraj=0</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b2261d09978&gt;</em>, <em class="sig-param">progress_bar=True</em>, <em class="sig-param">map_func=&lt;function parallel_map at 0x2b225f61c620&gt;</em>, <em class="sig-param">map_kwargs={}</em>, <em class="sig-param">_safe_mode=True</em>, <em class="sig-param">_exp=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/mcsolve.html#mcsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.mcsolve.mcsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte Carlo evolution of a state vector <span class="math notranslate nohighlight">\(|\psi \rangle\)</span> for a
given Hamiltonian and sets of collapse operators, and possibly, operators
for calculating expectation values. Options for the underlying ODE solver
are given by the Options class.</p>
<p>mcsolve supports time-dependent Hamiltonians and collapse operators using
either Python functions of strings to represent time-dependent
coefficients. Note that, the system Hamiltonian MUST have at least one
constant term.</p>
<p>As an example of a time-dependent problem, consider a Hamiltonian with two
terms <code class="docutils literal notranslate"><span class="pre">H0</span></code> and <code class="docutils literal notranslate"><span class="pre">H1</span></code>, where <code class="docutils literal notranslate"><span class="pre">H1</span></code> is time-dependent with coefficient
<code class="docutils literal notranslate"><span class="pre">sin(w*t)</span></code>, and collapse operators <code class="docutils literal notranslate"><span class="pre">C0</span></code> and <code class="docutils literal notranslate"><span class="pre">C1</span></code>, where <code class="docutils literal notranslate"><span class="pre">C1</span></code> is
time-dependent with coeffcient <code class="docutils literal notranslate"><span class="pre">exp(-a*t)</span></code>.  Here, w and a are constant
arguments with values <code class="docutils literal notranslate"><span class="pre">W</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>Using the Python function time-dependent format requires two Python
functions, one for each collapse coefficient. Therefore, this problem could
be expressed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">C1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">H1_coeff</span><span class="p">]]</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">C0</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C1_coeff</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>or in String (Cython) format we could write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s1">&#39;sin(w*t)&#39;</span><span class="p">]]</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">C0</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="s1">&#39;exp(-a*t)&#39;</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>Constant terms are preferably placed first in the Hamiltonian and collapse
operator lists.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, <code class="docutils literal notranslate"><span class="pre">list</span></code></span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial state vector</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>Times at which results are recorded.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int</span></dt><dd><p>Number of trajectories to run.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, <code class="docutils literal notranslate"><span class="pre">list</span></code></span></dt><dd><p>single collapse operator or a <code class="docutils literal notranslate"><span class="pre">list</span></code> of collapse operators.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, <code class="docutils literal notranslate"><span class="pre">list</span></code></span></dt><dd><p>single operator as Qobj or <code class="docutils literal notranslate"><span class="pre">list</span></code> or equivalent of Qobj operators
for calculating expectation values.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>Instance of ODE solver options.</p>
</dd>
<dt><strong>progress_bar: BaseProgressBar</strong></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation. Set to None to disable the
progress bar.</p>
</dd>
<dt><strong>map_func: function</strong></dt><dd><p>A map function for managing the calls to the single-trajactory solver.</p>
</dd>
<dt><strong>map_kwargs: dictionary</strong></dt><dd><p>Optional keyword arguments to the map_func function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt><dd><p>Object storing all results from the simulation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible to reuse the random number seeds from a previous run
of the mcsolver by passing the output Result object seeds via the
Options class, i.e. Options(seeds=prev_result.seeds).</p>
</div>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.essolve">
<span id="exponential-series"></span><h3>Exponential Series<a class="headerlink" href="#module-qutip.essolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.essolve.essolve">
<code class="sig-name descname">essolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">rho0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">c_op_list</em>, <em class="sig-param">e_ops</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/essolve.html#essolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.essolve.essolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolution of a state vector or density matrix (<cite>rho0</cite>) for a given
Hamiltonian (<cite>H</cite>) and set of collapse operators (<cite>c_op_list</cite>), by
expressing the ODE as an exponential series. The output is either
the state vector at arbitrary points in time (<cite>tlist</cite>), or the
expectation values of the supplied operators (<cite>e_ops</cite>).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">qobj/function_type</span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>Initial state density matrix.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list/array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_op_list</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> collapse operators.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> operators for which to evaluate
expectation values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>expt_array</strong><span class="classifier">array</span></dt><dd><p>Expectation values of wavefunctions/density matrices for the
times specified in <code class="docutils literal notranslate"><span class="pre">tlist</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This solver does not support time-dependent Hamiltonians.
..</p>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.essolve.ode2es">
<code class="sig-name descname">ode2es</code><span class="sig-paren">(</span><em class="sig-param">L</em>, <em class="sig-param">rho0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/essolve.html#ode2es"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.essolve.ode2es" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an exponential series that describes the time evolution for the
initial density matrix (or state vector) <cite>rho0</cite>, given the Liouvillian
(or Hamiltonian) <cite>L</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>L</strong><span class="classifier">qobj</span></dt><dd><p>Liouvillian of the system.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier">qobj</span></dt><dd><p>Initial state vector or density matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>eseries</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.eseries" title="qutip.eseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.eseries</span></code></a></span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">eseries</span></code> represention of the system dynamics.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.bloch_redfield">
<span id="bloch-redfield-master-equation"></span><h3>Bloch-Redfield Master Equation<a class="headerlink" href="#module-qutip.bloch_redfield" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.bloch_redfield.brmesolve">
<code class="sig-name descname">brmesolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">psi0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">a_ops=[]</em>, <em class="sig-param">e_ops=[]</em>, <em class="sig-param">c_ops=[]</em>, <em class="sig-param">args={}</em>, <em class="sig-param">use_secular=True</em>, <em class="sig-param">sec_cutoff=0.1</em>, <em class="sig-param">tol=1e-12</em>, <em class="sig-param">spectra_cb=None</em>, <em class="sig-param">options=None</em>, <em class="sig-param">progress_bar=None</em>, <em class="sig-param">_safe_mode=True</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch_redfield.html#brmesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch_redfield.brmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the dynamics of a system using the Bloch-Redfield master equation,
given an input Hamiltonian, Hermitian bath-coupling terms and their associated
spectrum functions, as well as possible Lindblad collapse operators.</p>
<p>For time-independent systems, the Hamiltonian must be given as a Qobj,
whereas the bath-coupling terms (a_ops), must be written as a nested list
of operator - spectrum function pairs, where the frequency is specified by
the <cite>w</cite> variable.</p>
<p><em>Example</em></p>
<blockquote>
<div><p>a_ops = [[a+a.dag(),lambda w: 0.2*(w&gt;=0)]]</p>
</div></blockquote>
<p>For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse
operators (c_ops), can be specified in the QuTiP string-based time-dependent
format.  For the a_op spectra, the frequency variable must be <cite>w</cite>, and the
string cannot contain any other variables other than the possibility of having
a time-dependence through the time variable <cite>t</cite>:</p>
<p><em>Example</em></p>
<blockquote>
<div><p>a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w&gt;=0)’]]</p>
</div></blockquote>
<p>It is also possible to use Cubic_Spline objects for time-dependence.  In
the case of a_ops, Cubic_Splines must be passed as a tuple:</p>
<p><em>Example</em></p>
<blockquote>
<div><p>a_ops = [ [a+a.dag(), ( f(w), g(t)] ]</p>
</div></blockquote>
<p>where f(w) and g(t) are strings or Cubic_spline objects for the bath
spectrum and time-dependence, respectively.</p>
<p>Finally, if one has bath-couplimg terms of the form
H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is</p>
<p><em>Example</em></p>
<blockquote>
<div><p>a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]</p>
</div></blockquote>
<p>where f(w) is the spectrum of the operators while g1(t) and g2(t)
are the time-dependence of the operators <cite>a</cite> and <cite>a.dag()</cite>, respectively</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">Qobj / list</span></dt><dd><p>System Hamiltonian given as a Qobj or
nested list in string-based format.</p>
</dd>
<dt><strong>psi0: Qobj</strong></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for evaluating evolution</p>
</dd>
<dt><strong>a_ops</strong><span class="classifier">list</span></dt><dd><p>Nested list of Hermitian system operators that couple to
the bath degrees of freedom, along with their associated
spectra.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list</span></dt><dd><p>List of operators for which to evaluate expectation values.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>List of system collapse operators, or nested list in
string-based format.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Placeholder for future implementation, kept for API consistency.</p>
</dd>
<dt><strong>use_secular</strong><span class="classifier">bool {True}</span></dt><dd><p>Use secular approximation when evaluating bath-coupling terms.</p>
</dd>
<dt><strong>sec_cutoff</strong><span class="classifier">float {0.1}</span></dt><dd><p>Cutoff for secular approximation.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float {qutip.setttings.atol}</span></dt><dd><p>Tolerance used for removing small values after
basis transformation.</p>
</dd>
<dt><strong>spectra_cb</strong><span class="classifier">list</span></dt><dd><p>DEPRECIATED. Do not use.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>Options for the solver.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">BaseProgressBar</span></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which contains
either an array of expectation values, for operators given in e_ops,
or a list of states for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.bloch_redfield.bloch_redfield_tensor">
<code class="sig-name descname">bloch_redfield_tensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculates the time-independent Bloch-Redfield tensor for a system given
a set of operators and corresponding spectral functions that describes the
system’s couplingto its environment.</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<dl class="simple">
<dt>a_ops<span class="classifier">list</span></dt><dd><p>Nested list of system operators that couple to the environment,
and the corresponding bath spectra represented as Python
functions.</p>
</dd>
<dt>spectra_cb<span class="classifier">list</span></dt><dd><p>Depreciated.</p>
</dd>
<dt>c_ops<span class="classifier">list</span></dt><dd><p>List of system collapse operators.</p>
</dd>
<dt>use_secular<span class="classifier">bool {True, False}</span></dt><dd><p>Flag that indicates if the secular approximation should
be used.</p>
</dd>
<dt>sec_cutoff<span class="classifier">float {0.1}</span></dt><dd><p>Threshold for secular approximation.</p>
</dd>
</dl>
</dd>
<dt><strong>atol</strong><span class="classifier">float {qutip.settings.atol}</span></dt><dd><p>Threshold for removing small parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>R, kets: <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></dt><dd><p>R is the Bloch-Redfield tensor and kets is a list eigenstates of the
Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.bloch_redfield.bloch_redfield_solve">
<code class="sig-name descname">bloch_redfield_solve</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">ekets</em>, <em class="sig-param">rho0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">e_ops=[]</em>, <em class="sig-param">options=None</em>, <em class="sig-param">progress_bar=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch_redfield.html#bloch_redfield_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolve the ODEs defined by Bloch-Redfield master equation. The
Bloch-Redfield tensor can be calculated by the function
<a class="reference internal" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="qutip.bloch_redfield.bloch_redfield_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">bloch_redfield_tensor</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>R</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>Bloch-Redfield tensor.</p>
</dd>
<dt><strong>ekets</strong><span class="classifier">array of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>Array of kets that make up a basis tranformation for the eigenbasis.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>Initial density matrix.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> / callback function</span></dt><dd><p>List of operators for which to evaluate expectation values.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qdeoptions</span></code></span></dt><dd><p>Options for the ODE solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.floquet">
<span id="floquet-states-and-floquet-markov-master-equation"></span><h3>Floquet States and Floquet-Markov Master Equation<a class="headerlink" href="#module-qutip.floquet" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.floquet.fmmesolve">
<code class="sig-name descname">fmmesolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">rho0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">c_ops=[]</em>, <em class="sig-param">e_ops=[]</em>, <em class="sig-param">spectra_cb=[]</em>, <em class="sig-param">T=None</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b226247fbe0&gt;</em>, <em class="sig-param">floquet_basis=True</em>, <em class="sig-param">kmax=5</em>, <em class="sig-param">_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#fmmesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.fmmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dynamics for the system using the Floquet-Markov master equation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This solver currently does not support multiple collapse operators.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>rho0 / psi0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> / callback function</span></dt><dd><p>list of operators for which to evaluate expectation values.</p>
</dd>
<dt><strong>spectra_cb</strong><span class="classifier">list callback functions</span></dt><dd><p>List of callback functions that compute the noise power spectrum as
a function of frequency for the collapse operators in <cite>c_ops</cite>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian. The default value
‘None’ indicates that the ‘tlist’ spans a single period of the driving.</p>
</dd>
<dt><strong>args</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
<p>This dictionary should also contain an entry ‘w_th’, which is
the temperature of the environment (if finite) in the
energy/frequency units of the Hamiltonian.  For example, if
the Hamiltonian written in units of 2pi GHz, and the
temperature is given in K, use the following conversion</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temperature</span> <span class="o">=</span> <span class="mf">25e-3</span> <span class="c1"># unit K</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">6.626e-34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kB</span> <span class="o">=</span> <span class="mf">1.38e-23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w_th&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperature</span> <span class="o">*</span> <span class="p">(</span><span class="n">kB</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mf">1e-9</span>
</pre></div>
</div>
</dd>
<dt><strong>options</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code></span></dt><dd><p>options for the ODE solver.</p>
</dd>
<dt><strong>k_max</strong><span class="classifier">int</span></dt><dd><p>The truncation of the number of sidebands (default 5).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code></span></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes">
<code class="sig-name descname">floquet_modes</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">T</em>, <em class="sig-param">args=None</em>, <em class="sig-param">sort=False</em>, <em class="sig-param">U=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the initial Floquet modes Phi_alpha(0) for a driven system with
period T.</p>
<p>Returns a list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> instances representing the Floquet
modes and a list of corresponding quasienergies, sorted by increasing
quasienergy in the interval [-pi/T, pi/T]. The optional parameter <cite>sort</cite>
decides if the output is to be sorted in increasing quasienergies or not.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>dictionary with variables required to evaluate H</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian. The default value
‘None’ indicates that the ‘tlist’ spans a single period of the driving.</p>
</dd>
<dt><strong>U</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>The propagator for the time-dependent Hamiltonian with period <cite>T</cite>.
If U is <cite>None</cite> (default), it will be calculated from the Hamiltonian
<cite>H</cite> using <a class="reference internal" href="#qutip.propagator.propagator" title="qutip.propagator.propagator"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.propagator.propagator</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">list of kets, list of quasi energies</span></dt><dd><p>Two lists: the Floquet modes as kets and the quasi energies.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_t">
<code class="sig-name descname">floquet_modes_t</code><span class="sig-paren">(</span><em class="sig-param">f_modes_0</em>, <em class="sig-param">f_energies</em>, <em class="sig-param">t</em>, <em class="sig-param">H</em>, <em class="sig-param">T</em>, <em class="sig-param">args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the
initial Floquet modes Phi_alpha(0)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_0</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt><dd><p>Floquet modes at <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">list</span></dt><dd><p>Floquet energies.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time at which to evaluate the floquet modes.</p>
</dd>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>dictionary with variables required to evaluate H</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">list of kets</span></dt><dd><p>The Floquet modes as kets at time <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_table">
<code class="sig-name descname">floquet_modes_table</code><span class="sig-paren">(</span><em class="sig-param">f_modes_0</em>, <em class="sig-param">f_energies</em>, <em class="sig-param">tlist</em>, <em class="sig-param">H</em>, <em class="sig-param">T</em>, <em class="sig-param">args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-calculate the Floquet modes for a range of times spanning the floquet
period. Can later be used as a table to look up the floquet modes for
any time.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_0</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt><dd><p>Floquet modes at <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">list</span></dt><dd><p>Floquet energies.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array</span></dt><dd><p>The list of times at which to evaluate the floquet modes.</p>
</dd>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>dictionary with variables required to evaluate H</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">nested list</span></dt><dd><p>A nested list of Floquet modes as kets for each time in <cite>tlist</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_t_lookup">
<code class="sig-name descname">floquet_modes_t_lookup</code><span class="sig-paren">(</span><em class="sig-param">f_modes_table_t</em>, <em class="sig-param">t</em>, <em class="sig-param">T</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes_t_lookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_t_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookup the floquet mode at time t in the pre-calculated table of floquet
modes in the first period of the time-dependence.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_table_t</strong><span class="classifier">nested list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt><dd><p>A lookup-table of Floquet modes at times precalculated by
<a class="reference internal" href="#qutip.floquet.floquet_modes_table" title="qutip.floquet.floquet_modes_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.floquet.floquet_modes_table</span></code></a>.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet modes.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">nested list</span></dt><dd><p>A list of Floquet modes as kets for the time that most closely matching
the time <cite>t</cite> in the supplied table of Floquet modes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_states">
<code class="sig-name descname">floquet_states</code><span class="sig-paren">(</span><em class="sig-param">f_modes_t</em>, <em class="sig-param">f_energies</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the floquet states at time t given the Floquet modes at that time.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_t</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt><dd><p>A list of Floquet modes for time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">list</span></dt><dd><p>A list of Floquet states for the time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_states_t">
<code class="sig-name descname">floquet_states_t</code><span class="sig-paren">(</span><em class="sig-param">f_modes_0</em>, <em class="sig-param">f_energies</em>, <em class="sig-param">t</em>, <em class="sig-param">H</em>, <em class="sig-param">T</em>, <em class="sig-param">args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_states_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_states_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the floquet states at time t given the initial Floquet modes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_t</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt><dd><p>A list of initial Floquet modes (for time <span class="math notranslate nohighlight">\(t=0\)</span>).</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet states.</p>
</dd>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>Dictionary with variables required to evaluate H.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">list</span></dt><dd><p>A list of Floquet states for the time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_wavefunction">
<code class="sig-name descname">floquet_wavefunction</code><span class="sig-paren">(</span><em class="sig-param">f_modes_t</em>, <em class="sig-param">f_energies</em>, <em class="sig-param">f_coeff</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_wavefunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_wavefunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the wavefunction for a time t using the Floquet state
decompositon, given the Floquet modes at time <cite>t</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_t</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt><dd><p>A list of initial Floquet modes (for time <span class="math notranslate nohighlight">\(t=0\)</span>).</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>f_coeff</strong><span class="classifier">array</span></dt><dd><p>The coefficients for Floquet decomposition of the initial wavefunction.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>The wavefunction for the time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_wavefunction_t">
<code class="sig-name descname">floquet_wavefunction_t</code><span class="sig-paren">(</span><em class="sig-param">f_modes_0</em>, <em class="sig-param">f_energies</em>, <em class="sig-param">f_coeff</em>, <em class="sig-param">t</em>, <em class="sig-param">H</em>, <em class="sig-param">T</em>, <em class="sig-param">args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_wavefunction_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_wavefunction_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the wavefunction for a time t using the Floquet state
decompositon, given the initial Floquet modes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_t</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt><dd><p>A list of initial Floquet modes (for time <span class="math notranslate nohighlight">\(t=0\)</span>).</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>f_coeff</strong><span class="classifier">array</span></dt><dd><p>The coefficients for Floquet decomposition of the initial wavefunction.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet states.</p>
</dd>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>Dictionary with variables required to evaluate H.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>The wavefunction for the time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_state_decomposition">
<code class="sig-name descname">floquet_state_decomposition</code><span class="sig-paren">(</span><em class="sig-param">f_states</em>, <em class="sig-param">f_energies</em>, <em class="sig-param">psi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_state_decomposition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_state_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose the wavefunction <cite>psi</cite> (typically an initial state) in terms of
the Floquet states, <span class="math notranslate nohighlight">\(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_states</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt><dd><p>A list of Floquet modes.</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>psi</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>The wavefunction to decompose in the Floquet state basis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array</span></dt><dd><p>The coefficients <span class="math notranslate nohighlight">\(c_\alpha\)</span> in the Floquet state decomposition.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.fsesolve">
<code class="sig-name descname">fsesolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">psi0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">e_ops=[]</em>, <em class="sig-param">T=None</em>, <em class="sig-param">args={}</em>, <em class="sig-param">Tsteps=100</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#fsesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.fsesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the Schrodinger equation using the Floquet formalism.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt><dd><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>Initial state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> / callback function</span></dt><dd><p>list of operators for which to evaluate expectation values. If this
list is empty, the state vectors for each time in <cite>tlist</cite> will be
returned instead of expectation values.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>Dictionary with variables required to evaluate H.</p>
</dd>
<dt><strong>Tsteps</strong><span class="classifier">integer</span></dt><dd><p>The number of time steps in one driving period for which to
precalculate the Floquet modes. <cite>Tsteps</cite> should be an even number.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which
contains either an <em>array</em> of expectation values or an array of
state vectors, for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_master_equation_rates">
<code class="sig-name descname">floquet_master_equation_rates</code><span class="sig-paren">(</span><em class="sig-param">f_modes_0</em>, <em class="sig-param">f_energies</em>, <em class="sig-param">c_op</em>, <em class="sig-param">H</em>, <em class="sig-param">T</em>, <em class="sig-param">args</em>, <em class="sig-param">J_cb</em>, <em class="sig-param">w_th</em>, <em class="sig-param">kmax=5</em>, <em class="sig-param">f_modes_table_t=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_master_equation_rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_master_equation_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the rates and matrix elements for the Floquet-Markov master
equation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_0</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt><dd><p>A list of initial Floquet modes.</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>The collapse operators describing the dissipation.</p>
</dd>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>Dictionary with variables required to evaluate H.</p>
</dd>
<dt><strong>J_cb</strong><span class="classifier">callback functions</span></dt><dd><p>A callback function that computes the noise power spectrum, as
a function of frequency, associated with the collapse operator <cite>c_op</cite>.</p>
</dd>
<dt><strong>w_th</strong><span class="classifier">float</span></dt><dd><p>The temperature in units of frequency.</p>
</dd>
<dt><strong>k_max</strong><span class="classifier">int</span></dt><dd><p>The truncation of the number of sidebands (default 5).</p>
</dd>
<dt><strong>f_modes_table_t</strong><span class="classifier">nested list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt><dd><p>A lookup-table of Floquet modes at times precalculated by
<a class="reference internal" href="#qutip.floquet.floquet_modes_table" title="qutip.floquet.floquet_modes_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.floquet.floquet_modes_table</span></code></a> (optional).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">list</span></dt><dd><p>A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma
and A used in the construction of the Floquet-Markov master equation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_master_equation_steadystate">
<code class="sig-name descname">floquet_master_equation_steadystate</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_master_equation_steadystate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_master_equation_steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the steadystate density matrix (in the floquet basis!) for the
Floquet-Markov master equation.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_basis_transform">
<code class="sig-name descname">floquet_basis_transform</code><span class="sig-paren">(</span><em class="sig-param">f_modes</em>, <em class="sig-param">f_energies</em>, <em class="sig-param">rho0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_basis_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_basis_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a basis transform that takes rho0 from the floquet basis to the
computational basis.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_markov_mesolve">
<code class="sig-name descname">floquet_markov_mesolve</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">ekets</em>, <em class="sig-param">rho0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">e_ops</em>, <em class="sig-param">f_modes_table=None</em>, <em class="sig-param">options=None</em>, <em class="sig-param">floquet_basis=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_markov_mesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_markov_mesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dynamics for the system using the Floquet-Markov master equation.</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.stochastic">
<span id="stochastic-schrodinger-equation-and-master-equation"></span><h3>Stochastic Schrödinger Equation and Master Equation<a class="headerlink" href="#module-qutip.stochastic" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.stochastic.smesolve">
<code class="sig-name descname">smesolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">rho0</em>, <em class="sig-param">times</em>, <em class="sig-param">c_ops=[]</em>, <em class="sig-param">sc_ops=[]</em>, <em class="sig-param">e_ops=[]</em>, <em class="sig-param">_safe_mode=True</em>, <em class="sig-param">args={}</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#smesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.smesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic master equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent system.</span></dt><dd><p>System Hamiltonian.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt><dd><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt><dd><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.ssesolve">
<code class="sig-name descname">ssesolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">psi0</em>, <em class="sig-param">times</em>, <em class="sig-param">sc_ops=[]</em>, <em class="sig-param">e_ops=[]</em>, <em class="sig-param">_safe_mode=True</em>, <em class="sig-param">args={}</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#ssesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.ssesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic schrodinger equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent system.</span></dt><dd><p>System Hamiltonian.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>State vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt><dd><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.smepdpsolve">
<code class="sig-name descname">smepdpsolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">rho0</em>, <em class="sig-param">times</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">e_ops</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#smepdpsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.smepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for density matrix
evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial density matrix.</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function single</span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.ssepdpsolve">
<code class="sig-name descname">ssepdpsolve</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">psi0</em>, <em class="sig-param">times</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">e_ops</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#ssepdpsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.ssepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for wavefunction
evolution. For most purposes, use <a class="reference internal" href="#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve</span></code></a> instead for quantum
trajectory simulations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial state vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function single</span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.correlation">
<span id="correlation-functions"></span><h3>Correlation Functions<a class="headerlink" href="#module-qutip.correlation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.correlation.correlation">
<code class="sig-name descname">correlation</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">state0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">taulist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em>, <em class="sig-param">solver='me'</em>, <em class="sig-param">reverse=False</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b22624eab00&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier"><em>bool</em></span></dt><dd><p>If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">array</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_ss">
<code class="sig-name descname">correlation_ss</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">taulist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em>, <em class="sig-param">solver='me'</em>, <em class="sig-param">reverse=False</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b22624eaac8&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_ss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:</p>
<div class="math notranslate nohighlight">
\[\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\]</div>
<p>along one time axis (given steady-state initial conditions) using the
quantum regression theorem and the evolution solver indicated by the
<cite>solver</cite> parameter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier"><em>bool</em></span></dt><dd><p>If <cite>True</cite>, calculate
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_vec</strong><span class="classifier">array</span></dt><dd><p>An array of correlation values for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_2op_1t">
<code class="sig-name descname">correlation_2op_1t</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">state0</em>, <em class="sig-param">taulist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em>, <em class="sig-param">solver='me'</em>, <em class="sig-param">reverse=False</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b22624ea978&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_2op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_2op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the evolution
solver indicated by the <cite>solver</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier">bool {False, True}</span></dt><dd><p>If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str {‘me’, ‘mc’, ‘es’}</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>Solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_vec</strong><span class="classifier">ndarray</span></dt><dd><p>An array of correlation values for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_2op_2t">
<code class="sig-name descname">correlation_2op_2t</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">state0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">taulist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em>, <em class="sig-param">solver='me'</em>, <em class="sig-param">reverse=False</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b22624ea9b0&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_2op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_2op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho_0\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi_0\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier">bool {False, True}</span></dt><dd><p>If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_3op_1t">
<code class="sig-name descname">correlation_3op_1t</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">state0</em>, <em class="sig-param">taulist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em>, <em class="sig-param">c_op</em>, <em class="sig-param">solver='me'</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b22624ea9e8&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_3op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_3op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator C.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_vec</strong><span class="classifier">array</span></dt><dd><p>An array of correlation values for the times specified by <cite>taulist</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_3op_2t">
<code class="sig-name descname">correlation_3op_2t</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">state0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">taulist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em>, <em class="sig-param">c_op</em>, <em class="sig-param">solver='me'</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b22624eaa20&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_3op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_3op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho_0\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi_0\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator C.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">array</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_4op_1t">
<code class="sig-name descname">correlation_4op_1t</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">state0</em>, <em class="sig-param">taulist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em>, <em class="sig-param">c_op</em>, <em class="sig-param">d_op</em>, <em class="sig-param">solver='me'</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b22624eab38&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_4op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_4op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator C.</p>
</dd>
<dt><strong>d_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator D.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_vec</strong><span class="classifier">array</span></dt><dd><p>An array of correlation values for the times specified by <cite>taulist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Deprecated in QuTiP 3.1
Use correlation_3op_1t() instead.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_4op_2t">
<code class="sig-name descname">correlation_4op_2t</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">state0</em>, <em class="sig-param">tlist</em>, <em class="sig-param">taulist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em>, <em class="sig-param">c_op</em>, <em class="sig-param">d_op</em>, <em class="sig-param">solver='me'</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b22624eab70&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_4op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_4op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho_0\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi_0\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator C.</p>
</dd>
<dt><strong>d_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator D.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">array</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum">
<code class="sig-name descname">spectrum</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">wlist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em>, <em class="sig-param">solver='es'</em>, <em class="sig-param">use_pinv=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using the solver indicated by the <cite>solver</cite> parameter. Note: this spectrum
is only defined for stationary statistics (uses steady state rho0)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>wlist</strong><span class="classifier">array_like</span></dt><dd><p>list of frequencies for <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>es</cite> for exponential series and
<cite>pi</cite> for psuedo-inverse).</p>
</dd>
<dt><strong>use_pinv</strong><span class="classifier">bool</span></dt><dd><p>For use with the <cite>pi</cite> solver: if <cite>True</cite> use numpy’s pinv method,
otherwise use a generic solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spectrum</strong><span class="classifier">array</span></dt><dd><p>An array with spectrum <span class="math notranslate nohighlight">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_ss">
<code class="sig-name descname">spectrum_ss</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">wlist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum_ss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using an eseries based solver Note: this spectrum is only defined for
stationary statistics (uses steady state rho0).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>wlist</strong><span class="classifier">array_like</span></dt><dd><p>list of frequencies for <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier"><em>list</em> of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>use_pinv</strong><span class="classifier"><em>bool</em></span></dt><dd><p>If <cite>True</cite> use numpy’s <cite>pinv</cite> method, otherwise use a generic solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spectrum</strong><span class="classifier">array</span></dt><dd><p>An array with spectrum <span class="math notranslate nohighlight">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_pi">
<code class="sig-name descname">spectrum_pi</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">wlist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">b_op</em>, <em class="sig-param">use_pinv=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum_pi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using a psuedo-inverse method. Note: this spectrum is only defined for
stationary statistics (uses steady state rho0)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>wlist</strong><span class="classifier">array_like</span></dt><dd><p>list of frequencies for <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier"><em>list</em> of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>use_pinv</strong><span class="classifier"><em>bool</em></span></dt><dd><p>If <cite>True</cite> use numpy’s pinv method, otherwise use a generic solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spectrum</strong><span class="classifier">array</span></dt><dd><p>An array with spectrum <span class="math notranslate nohighlight">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_correlation_fft">
<code class="sig-name descname">spectrum_correlation_fft</code><span class="sig-paren">(</span><em class="sig-param">tlist</em>, <em class="sig-param">y</em>, <em class="sig-param">inverse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum_correlation_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_correlation_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the power spectrum corresponding to a two-time correlation
function using FFT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list/array of times <span class="math notranslate nohighlight">\(t\)</span> which the correlation function is given.</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>list/array of correlations corresponding to time delays <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>inverse: boolean</strong></dt><dd><p>boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w, S</strong><span class="classifier">tuple</span></dt><dd><p>Returns an array of angular frequencies ‘w’ and the corresponding
two-sided power spectrum ‘S(w)’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.coherence_function_g1">
<code class="sig-name descname">coherence_function_g1</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">state0</em>, <em class="sig-param">taulist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">solver='me'</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b22624eaa58&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#coherence_function_g1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.coherence_function_g1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normalized first-order quantum coherence function:</p>
<div class="math notranslate nohighlight">
\[g^{(1)}(\tau) =
\frac{\langle A^\dagger(\tau)A(0)\rangle}
{\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle
        \langle A^\dagger(0)A(0)\rangle}}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>g1, G1</strong><span class="classifier">tuple</span></dt><dd><p>The normalized and unnormalized second-order coherence function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.coherence_function_g2">
<code class="sig-name descname">coherence_function_g2</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">state0</em>, <em class="sig-param">taulist</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">a_op</em>, <em class="sig-param">solver='me'</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b22624eaa90&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#coherence_function_g2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.coherence_function_g2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normalized second-order quantum coherence function:</p>
<div class="math notranslate nohighlight">
\[ g^{(2)}(\tau) =
\frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}
{\langle A^\dagger(\tau)A(\tau)\rangle
 \langle A^\dagger(0)A(0)\rangle}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of arguments to be passed to solver.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>g2, G2</strong><span class="classifier">tuple</span></dt><dd><p>The normalized and unnormalized second-order coherence function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.steadystate">
<span id="steady-state-solvers"></span><h3>Steady-state Solvers<a class="headerlink" href="#module-qutip.steadystate" title="Permalink to this headline">¶</a></h3>
<p>Module contains functions for solving for the steady state density matrix of
open quantum systems defined by a Liouvillian or Hamiltonian and a list of
collapse operators.</p>
<dl class="function">
<dt id="qutip.steadystate.steadystate">
<code class="sig-name descname">steadystate</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">c_op_list=[]</em>, <em class="sig-param">method='direct'</em>, <em class="sig-param">solver=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/steadystate.html#steadystate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.steadystate.steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the steady state for quantum evolution subject to the
supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a
list of collapse operators.</p>
<p>If the user passes a Hamiltonian then it, along with the list of collapse
operators, will be converted into a Liouvillian operator in Lindblad form.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>A Hamiltonian or Liouvillian operator.</p>
</dd>
<dt><strong>c_op_list</strong><span class="classifier">list</span></dt><dd><p>A list of collapse operators.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str {None, ‘scipy’, ‘mkl’}</span></dt><dd><p>Selects the sparse solver to use.  Default is auto-select
based on the availability of the MKL library.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str {‘direct’, ‘eigen’, ‘iterative-gmres’,</span></dt><dd><blockquote>
<div><p>‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,
‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}</p>
</div></blockquote>
<p>Method for solving the underlying linear equation. Direct LU solver
‘direct’ (default), sparse eigenvalue problem ‘eigen’,
iterative GMRES method ‘iterative-gmres’, iterative LGMRES method
‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,
SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative
power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use
the same solvers as their direct counterparts.</p>
</dd>
<dt><strong>return_info</strong><span class="classifier">bool, optional, default = False</span></dt><dd><p>Return a dictionary of solver-specific infomation about the
solution and how it was obtained.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional, default = True</span></dt><dd><p>Solve for the steady state using sparse algorithms. If set to False,
the underlying Liouvillian operator will be converted into a dense
matrix. Use only for ‘smaller’ systems.</p>
</dd>
<dt><strong>use_rcm</strong><span class="classifier">bool, optional, default = False</span></dt><dd><p>Use reverse Cuthill-Mckee reordering to minimize fill-in in the
LU factorization of the Liouvillian.</p>
</dd>
<dt><strong>use_wbm</strong><span class="classifier">bool, optional, default = False</span></dt><dd><p>Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> by default when finding a preconditioner.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">float, optional</span></dt><dd><p>Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</dd>
<dt><strong>max_iter_refine</strong><span class="classifier">int {10}</span></dt><dd><p>MKL ONLY. Max. number of iterative refinements to perform.</p>
</dd>
<dt><strong>scaling_vectors</strong><span class="classifier">bool {True, False}</span></dt><dd><p>MKL ONLY.  Scale matrix to unit norm columns and rows.</p>
</dd>
<dt><strong>weighted_matching</strong><span class="classifier">bool {True, False}</span></dt><dd><p>MKL ONLY.  Use weighted matching to better condition diagonal.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">ndarray, optional</span></dt><dd><p>ITERATIVE ONLY. Initial guess for solution vector.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int, optional, default=1000</span></dt><dd><p>ITERATIVE ONLY. Maximum number of iterations to perform.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional, default=1e-12</span></dt><dd><p>ITERATIVE ONLY. Tolerance used for terminating solver.</p>
</dd>
<dt><strong>mtol</strong><span class="classifier">float, optional, default=None</span></dt><dd><p>ITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.
If None given then <cite>max(0.1*tol, 1e-15)</cite> is used</p>
</dd>
<dt><strong>matol</strong><span class="classifier">float, optional, default=1e-15</span></dt><dd><p>ITERATIVE ONLY. Absolute tolerance for lu solve method.</p>
</dd>
<dt><strong>permc_spec</strong><span class="classifier">str, optional, default=’COLAMD’</span></dt><dd><p>ITERATIVE ONLY. Column ordering used internally by superLU for the
‘direct’ LU decomposition method. Options include ‘COLAMD’ and
‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically
unless explicitly specified.</p>
</dd>
<dt><strong>use_precond</strong><span class="classifier">bool optional, default = False</span></dt><dd><p>ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a
preconditioner for the ‘iterative’ GMRES and BICG solvers.
Speeds up convergence time by orders of magnitude in many cases.</p>
</dd>
<dt><strong>M</strong><span class="classifier">{sparse matrix, dense matrix, LinearOperator}, optional</span></dt><dd><p>ITERATIVE ONLY. Preconditioner for A. The preconditioner should
approximate the inverse of A. Effective preconditioning can
dramatically improve the rate of convergence for iterative methods.
If no preconditioner is given and <code class="docutils literal notranslate"><span class="pre">use_precond</span> <span class="pre">=</span> <span class="pre">True</span></code>, then one
is generated automatically.</p>
</dd>
<dt><strong>fill_factor</strong><span class="classifier">float, optional, default = 100</span></dt><dd><p>ITERATIVE ONLY. Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</dd>
<dt><strong>drop_tol</strong><span class="classifier">float, optional, default = 1e-4</span></dt><dd><p>ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</dd>
<dt><strong>diag_pivot_thresh</strong><span class="classifier">float, optional, default = None</span></dt><dd><p>ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</dd>
<dt><strong>ILU_MILU</strong><span class="classifier">str, optional, default = ‘smilu_2’</span></dt><dd><p>ITERATIVE ONLY. Selects the incomplete LU decomposition method
algoithm used in creating the preconditoner. Should only be used by
advanced users.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Steady state density matrix.</p>
</dd>
<dt><strong>info</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary containing solver-specific information about the solution.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The SVD method works only for dense operators (i.e. small systems).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.steadystate.build_preconditioner">
<code class="sig-name descname">build_preconditioner</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">c_op_list=[]</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/steadystate.html#build_preconditioner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.steadystate.build_preconditioner" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a iLU preconditioner necessary for solving for
the steady state density matrix using the iterative linear solvers
in the ‘steadystate’ function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>A Hamiltonian or Liouvillian operator.</p>
</dd>
<dt><strong>c_op_list</strong><span class="classifier">list</span></dt><dd><p>A list of collapse operators.</p>
</dd>
<dt><strong>return_info</strong><span class="classifier">bool, optional, default = False</span></dt><dd><p>Return a dictionary of solver-specific infomation about the
solution and how it was obtained.</p>
</dd>
<dt><strong>use_rcm</strong><span class="classifier">bool, optional, default = False</span></dt><dd><p>Use reverse Cuthill-Mckee reordering to minimize fill-in in the
LU factorization of the Liouvillian.</p>
</dd>
<dt><strong>use_wbm</strong><span class="classifier">bool, optional, default = False</span></dt><dd><p>Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> by default when finding a preconditioner.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">float, optional</span></dt><dd><p>Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, default = ‘iterative’</span></dt><dd><p>Tells the preconditioner what type of Liouvillian to build for
iLU factorization.  For direct iterative methods use ‘iterative’.
For power iterative methods use ‘power’.</p>
</dd>
<dt><strong>permc_spec</strong><span class="classifier">str, optional, default=’COLAMD’</span></dt><dd><p>Column ordering used internally by superLU for the
‘direct’ LU decomposition method. Options include ‘COLAMD’ and
‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically
unless explicitly specified.</p>
</dd>
<dt><strong>fill_factor</strong><span class="classifier">float, optional, default = 100</span></dt><dd><p>Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</dd>
<dt><strong>drop_tol</strong><span class="classifier">float, optional, default = 1e-4</span></dt><dd><p>Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</dd>
<dt><strong>diag_pivot_thresh</strong><span class="classifier">float, optional, default = None</span></dt><dd><p>Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</dd>
<dt><strong>ILU_MILU</strong><span class="classifier">str, optional, default = ‘smilu_2’</span></dt><dd><p>Selects the incomplete LU decomposition method algoithm used in
creating the preconditoner. Should only be used by advanced users.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lu</strong><span class="classifier">object</span></dt><dd><p>Returns a SuperLU object representing iLU preconditioner.</p>
</dd>
<dt><strong>info</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary containing solver-specific information.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.propagator">
<span id="propagators"></span><h3>Propagators<a class="headerlink" href="#module-qutip.propagator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.propagator.propagator">
<code class="sig-name descname">propagator</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">t</em>, <em class="sig-param">c_op_list=[]</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=None</em>, <em class="sig-param">unitary_mode='batch'</em>, <em class="sig-param">parallel=False</em>, <em class="sig-param">progress_bar=None</em>, <em class="sig-param">_safe_mode=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/propagator.html#propagator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.propagator.propagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator U(t) for the density matrix or wave function such
that <span class="math notranslate nohighlight">\(\psi(t) = U(t)\psi(0)\)</span> or
<span class="math notranslate nohighlight">\(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathrm vec}\)</span> is the vector representation of the
density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">qobj or list</span></dt><dd><p>Hamiltonian as a Qobj instance of a nested list of Qobjs and
coefficients in the list-string or list-function format for
time-dependent Hamiltonians (see description in <a class="reference internal" href="#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a>).</p>
</dd>
<dt><strong>t</strong><span class="classifier">float or array-like</span></dt><dd><p>Time or list of times for which to evaluate the propagator.</p>
</dd>
<dt><strong>c_op_list</strong><span class="classifier">list</span></dt><dd><p>List of qobj collapse operators.</p>
</dd>
<dt><strong>args</strong><span class="classifier">list/array/dictionary</span></dt><dd><p>Parameters to callback functions for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Options</span></code></span></dt><dd><p>with options for the ODE solver.</p>
</dd>
<dt><strong>unitary_mode = str (‘batch’, ‘single’)</strong></dt><dd><p>Solve all basis vectors simulaneously (‘batch’) or individually
(‘single’).</p>
</dd>
<dt><strong>parallel</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Run the propagator in parallel mode. This will override the
unitary_mode settings if set to True.</p>
</dd>
<dt><strong>progress_bar: BaseProgressBar</strong></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation. By default no progress bar
is used, and if set to True a TextProgressBar will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a</strong><span class="classifier">qobj</span></dt><dd><p>Instance representing the propagator <span class="math notranslate nohighlight">\(U(t)\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.propagator.propagator_steadystate">
<code class="sig-name descname">propagator_steadystate</code><span class="sig-paren">(</span><em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/propagator.html#propagator_steadystate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.propagator.propagator_steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the steady state for successive applications of the propagator
<span class="math notranslate nohighlight">\(U\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">qobj</span></dt><dd><p>Operator representing the propagator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a</strong><span class="classifier">qobj</span></dt><dd><p>Instance representing the steady-state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.rhs_generate">
<span id="time-dependent-problems"></span><h3>Time-dependent problems<a class="headerlink" href="#module-qutip.rhs_generate" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.rhs_generate.rhs_generate">
<code class="sig-name descname">rhs_generate</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">args={}</em>, <em class="sig-param">options=&lt;qutip.solver.Options object at 0x2b225f631c18&gt;</em>, <em class="sig-param">name=None</em>, <em class="sig-param">cleanup=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/rhs_generate.html#rhs_generate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.rhs_generate.rhs_generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the Cython functions needed for solving the dynamics of a
given system using the mesolve function inside a parfor loop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">qobj</span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of collapse operators.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>Instance of ODE solver options.</p>
</dd>
<dt><strong>name: str</strong></dt><dd><p>Name of generated RHS</p>
</dd>
<dt><strong>cleanup: bool</strong></dt><dd><p>Whether the generated cython file should be automatically removed or
not.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Using this function with any solver other than the mesolve function
will result in an error.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.rhs_generate.rhs_clear">
<code class="sig-name descname">rhs_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/rhs_generate.html#rhs_clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.rhs_generate.rhs_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the string-format time-dependent Hamiltonian parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Nothing, just clears data from internal config module.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.scattering">
<span id="scattering-in-quantum-optical-systems"></span><h3>Scattering in Quantum Optical Systems<a class="headerlink" href="#module-qutip.scattering" title="Permalink to this headline">¶</a></h3>
<p>Photon scattering in quantum optical systems</p>
<p>This module includes a collection of functions for numerically computing photon
scattering in driven arbitrary systems coupled to some configuration of output
waveguides. The implementation of these functions closely follows the
mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent
Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).</p>
<dl class="function">
<dt id="qutip.scattering.temporal_basis_vector">
<code class="sig-name descname">temporal_basis_vector</code><span class="sig-paren">(</span><em class="sig-param">waveguide_emission_indices</em>, <em class="sig-param">n_time_bins</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/scattering.html#temporal_basis_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.scattering.temporal_basis_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a temporal basis vector for emissions at specified time bins into
specified waveguides.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>waveguide_emission_indices</strong><span class="classifier">list or tuple</span></dt><dd><p>List of indices where photon emission occurs for each waveguide,
e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].</p>
</dd>
<dt><strong>n_time_bins</strong><span class="classifier">int</span></dt><dd><p>Number of time bins; the range over which each index can vary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>temporal_basis_vector</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>A basis vector representing photon scattering at the specified indices.
If there are W waveguides, T times, and N photon emissions, then the
basis vector has dimensionality (W*T)^N.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.scattering.temporal_scattered_state">
<code class="sig-name descname">temporal_scattered_state</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">psi0</em>, <em class="sig-param">n_emissions</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">tlist</em>, <em class="sig-param">system_zero_state=None</em>, <em class="sig-param">construct_effective_hamiltonian=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/scattering.html#temporal_scattered_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.scattering.temporal_scattered_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the scattered n-photon state projected onto the temporal basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">:class: qutip.Qobj or list</span></dt><dd><p>System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or
list-callback format. If construct_effective_hamiltonian is not
specified, an effective Hamiltonian is constructed from <cite>H</cite> and
<cite>c_ops</cite>.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>.</p>
</dd>
<dt><strong>n_emissions</strong><span class="classifier">int</span></dt><dd><p>Number of photon emissions to calculate.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>List of collapse operators for each waveguide; these are assumed to
include spontaneous decay rates, e.g.
<span class="math notranslate nohighlight">\(\sigma = \sqrt \gamma \cdot a\)</span></p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau_i\)</span>. tlist should contain 0 and exceed
the pulse duration / temporal region of interest.</p>
</dd>
<dt><strong>system_zero_state</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>State representing zero excitations in the system. Defaults to
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span></p>
</dd>
<dt><strong>construct_effective_hamiltonian</strong><span class="classifier">bool</span></dt><dd><p>Whether an effective Hamiltonian should be constructed from H and c_ops:
<span class="math notranslate nohighlight">\(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\)</span>
Default: True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phi_n</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>The scattered bath state projected onto the temporal basis given by
tlist. If there are W waveguides, T times, and N photon emissions, then
the state is a tensor product state with dimensionality T^(W*N).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.scattering.scattering_probability">
<code class="sig-name descname">scattering_probability</code><span class="sig-paren">(</span><em class="sig-param">H</em>, <em class="sig-param">psi0</em>, <em class="sig-param">n_emissions</em>, <em class="sig-param">c_ops</em>, <em class="sig-param">tlist</em>, <em class="sig-param">system_zero_state=None</em>, <em class="sig-param">construct_effective_hamiltonian=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/scattering.html#scattering_probability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.scattering.scattering_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integrated probability of scattering n photons in an arbitrary
system. This function accepts a nonlinearly spaced array of times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">:class: qutip.Qobj or list</span></dt><dd><p>System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or
list-callback format. If construct_effective_hamiltonian is not
specified, an effective Hamiltonian is constructed from H and
<cite>c_ops</cite>.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>.</p>
</dd>
<dt><strong>n_emissions</strong><span class="classifier">int</span></dt><dd><p>Number of photons emitted by the system (into any combination of
waveguides).</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>List of collapse operators for each waveguide; these are assumed to
include spontaneous decay rates, e.g.
<span class="math notranslate nohighlight">\(\sigma = \sqrt \gamma \cdot a\)</span>.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau_i\)</span>. tlist should contain 0 and exceed
the pulse duration / temporal region of interest; tlist need not be
linearly spaced.</p>
</dd>
<dt><strong>system_zero_state</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>State representing zero excitations in the system. Defaults to
<cite>basis(systemDims, 0)</cite>.</p>
</dd>
<dt><strong>construct_effective_hamiltonian</strong><span class="classifier">bool</span></dt><dd><p>Whether an effective Hamiltonian should be constructed from H and c_ops:
<span class="math notranslate nohighlight">\(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\)</span>
Default: True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scattering_prob</strong><span class="classifier">float</span></dt><dd><p>The probability of scattering n photons from the system over the time
range specified.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.piqs">
<span id="permutational-invariance"></span><h3>Permutational Invariance<a class="headerlink" href="#module-qutip.piqs" title="Permalink to this headline">¶</a></h3>
<p>Permutational Invariant Quantum Solver (PIQS)</p>
<p>This module calculates the Liouvillian for the dynamics of ensembles of
identical two-level systems (TLS) in the presence of local and collective
processes by exploiting permutational symmetry and using the Dicke basis.</p>
<dl class="function">
<dt id="qutip.piqs.jspin">
<code class="sig-name descname">jspin</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">op=None</em>, <em class="sig-param">basis='dicke'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#jspin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.jspin" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the list of collective operators of the total algebra.</p>
<p>The Dicke basis <span class="math notranslate nohighlight">\(|j,m\rangle\langle j,m'|\)</span> is used by
default. Otherwise with “uncoupled” the operators are in a
<span class="math notranslate nohighlight">\(2^N\)</span> space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>Number of two-level systems.</p>
</dd>
<dt><strong>op: str</strong></dt><dd><p>The operator to return ‘x’,’y’,’z’,’+’,’-‘.
If no operator given, then output is the list of operators
for [‘x’,’y’,’z’].</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis of the operators - “dicke” or “uncoupled”
default: “dicke”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>j_alg: list or :class: qutip.Qobj</dt><dd><p>A list of <cite>qutip.Qobj</cite> representing all the operators in
the “dicke” or “uncoupled” basis or a single operator requested.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.dicke">
<code class="sig-name descname">dicke</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">j</em>, <em class="sig-param">m</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#dicke"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.dicke" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a Dicke state as a pure density matrix in the Dicke basis.</p>
<p>For instance, the superradiant state given by
<span class="math notranslate nohighlight">\(|j, m\rangle = |1, 0\rangle\)</span> for N = 2,
and the state is represented as a density matrix of size (nds, nds) or
(4, 4), with the (1, 1) element set to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>j: float</strong></dt><dd><p>The eigenvalue j of the Dicke state (j, m).</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>The eigenvalue m of the Dicke state (j, m).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>rho: :class: qutip.Qobj</dt><dd><p>The density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.superradiant">
<code class="sig-name descname">superradiant</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">basis='dicke'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#superradiant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.superradiant" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density matrix of the superradiant state.</p>
<p>This state is given by (N/2, 0) or (N/2, 0.5) in the Dicke basis.
If the argument <cite>basis</cite> is “uncoupled” then it generates the state
in a 2**N dim Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The superradiant state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.ghz">
<code class="sig-name descname">ghz</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">basis='dicke'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#ghz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.ghz" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density matrix of the GHZ state.</p>
<p>If the argument <cite>basis</cite> is “uncoupled” then it generates the state
in a <span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The GHZ state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.css">
<code class="sig-name descname">css</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">x=0.7071067811865475</em>, <em class="sig-param">y=0.7071067811865475</em>, <em class="sig-param">basis='dicke'</em>, <em class="sig-param">coordinates='cartesian'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#css"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.css" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density matrix of the Coherent Spin State (CSS).</p>
<p>It can be defined as,
<span class="math notranslate nohighlight">\(|CSS \rangle = \prod_i^N(a|1\rangle_i + b|0\rangle_i)\)</span>
with <span class="math notranslate nohighlight">\(a = sin(\frac{\theta}{2})\)</span>,
<span class="math notranslate nohighlight">\(b = e^{i \phi}\cos(\frac{\theta}{2})\)</span>.
The default basis is that of Dicke space
<span class="math notranslate nohighlight">\(|j, m\rangle \langle j, m'|\)</span>.
The default state is the symmetric CSS,
<span class="math notranslate nohighlight">\(|CSS\rangle = |+\rangle\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>x, y: float</strong></dt><dd><p>The coefficients of the CSS state.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
<dt><strong>coordinates: str</strong></dt><dd><p>Either “cartesian” or “polar”. If polar then the coefficients
are constructed as sin(x/2), cos(x/2)e^(iy).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>rho: :class: qutip.Qobj</dt><dd><p>The CSS state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.excited">
<code class="sig-name descname">excited</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">basis='dicke'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#excited"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.excited" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density matrix for the excited state.</p>
<p>This state is given by (N/2, N/2) in the default Dicke basis. If the
argument <cite>basis</cite> is “uncoupled” then it generates the state in a
2**N dim Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The excited state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.ground">
<code class="sig-name descname">ground</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">basis='dicke'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#ground"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.ground" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density matrix of the ground state.</p>
<p>This state is given by (N/2, -N/2) in the Dicke basis. If the argument
<cite>basis</cite> is “uncoupled” then it generates the state in a
<span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The ground state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.num_dicke_states">
<code class="sig-name descname">num_dicke_states</code><span class="sig-paren">(</span><em class="sig-param">N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#num_dicke_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.num_dicke_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of Dicke states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>nds: int</dt><dd><p>The number of Dicke states.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.num_dicke_ladders">
<code class="sig-name descname">num_dicke_ladders</code><span class="sig-paren">(</span><em class="sig-param">N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#num_dicke_ladders"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.num_dicke_ladders" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total number of ladders in the Dicke space.</p>
<p>For a collection of N two-level systems it counts how many different
“j” exist or the number of blocks in the block-diagonal matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Nj: int</dt><dd><p>The number of Dicke ladders.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.num_tls">
<code class="sig-name descname">num_tls</code><span class="sig-paren">(</span><em class="sig-param">nds</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#num_tls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.num_tls" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of two-level systems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nds: int</strong></dt><dd><p>The number of Dicke states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>N: int</dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.isdiagonal">
<code class="sig-name descname">isdiagonal</code><span class="sig-paren">(</span><em class="sig-param">mat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#isdiagonal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.isdiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the input matrix is diagonal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mat: ndarray/Qobj</strong></dt><dd><p>A 2D numpy array</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>diag: bool</dt><dd><p>True/False depending on whether the input matrix is diagonal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.state_degeneracy">
<code class="sig-name descname">state_degeneracy</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#state_degeneracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.state_degeneracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the degeneracy of the Dicke state.</p>
<p>Each state <span class="math notranslate nohighlight">\(|j, m\rangle\)</span> includes D(N,j) irreducible
representations <span class="math notranslate nohighlight">\(|j, m, \alpha\rangle\)</span>.</p>
<p>Uses Decimals to calculate higher numerator and denominators numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>j: float</strong></dt><dd><p>Total spin eigenvalue (cooperativity).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>degeneracy: int</dt><dd><p>The state degeneracy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.m_degeneracy">
<code class="sig-name descname">m_degeneracy</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">m</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#m_degeneracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.m_degeneracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of Dicke states <span class="math notranslate nohighlight">\(|j, m\rangle\)</span> with
same energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>Total spin z-axis projection eigenvalue (proportional to the total
energy).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>degeneracy: int</dt><dd><p>The m-degeneracy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.ap">
<code class="sig-name descname">ap</code><span class="sig-paren">(</span><em class="sig-param">j</em>, <em class="sig-param">m</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#ap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.ap" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the coefficient <cite>ap</cite> by applying J_+ <a href="#id41"><span class="problematic" id="id42">|</span></a>j, m&gt;.</p>
<p>The action of ap is given by:
<span class="math notranslate nohighlight">\(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j, m: float</strong></dt><dd><p>The value for j and m in the dicke basis <a href="#id43"><span class="problematic" id="id44">|</span></a>j,m&gt;.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>a_plus: float</dt><dd><p>The value of <span class="math notranslate nohighlight">\(a_{+}\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.am">
<code class="sig-name descname">am</code><span class="sig-paren">(</span><em class="sig-param">j</em>, <em class="sig-param">m</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#am"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.am" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the operator <cite>am</cite> used later.</p>
<p>The action of ap is given by: J_{-}|j, m&gt; = A_{-}(jm)|j, m-1&gt;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j: float</strong></dt><dd><p>The value for j.</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>The value for m.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>a_minus: float</dt><dd><p>The value of <span class="math notranslate nohighlight">\(a_{-}\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.spin_algebra">
<code class="sig-name descname">spin_algebra</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">op=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#spin_algebra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.spin_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the list [sx, sy, sz] with the spin operators.</p>
<p>The operators are constructed for a collection of N two-level systems
(TLSs). Each element of the list, i.e., sx, is a vector of <cite>qutip.Qobj</cite>
objects (spin matrices), as it cointains the list of the SU(2) Pauli
matrices for the N TLSs. Each TLS operator sx[i], with i = 0, …, (N-1),
is placed in a <span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>spin_operators: list or :class: qutip.Qobj</dt><dd><p>A list of <cite>qutip.Qobj</cite> operators - [sx, sy, sz] or the
requested operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>sx[i] is <span class="math notranslate nohighlight">\(\frac{\sigma_x}{2}\)</span> in the composite Hilbert space.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.collapse_uncoupled">
<code class="sig-name descname">collapse_uncoupled</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">emission=0.0</em>, <em class="sig-param">dephasing=0.0</em>, <em class="sig-param">pumping=0.0</em>, <em class="sig-param">collective_emission=0.0</em>, <em class="sig-param">collective_dephasing=0.0</em>, <em class="sig-param">collective_pumping=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#collapse_uncoupled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.collapse_uncoupled" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the collapse operators (c_ops) of the Lindbladian in the
uncoupled basis</p>
<p>These operators are in the uncoupled basis of the two-level
system (TLS) SU(2) Pauli matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>c_ops: list</dt><dd><p>The list of collapse operators as <cite>qutip.Qobj</cite> for the system.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The collapse operator list can be given to <cite>qutip.mesolve</cite>.
Notice that the operators are placed in a Hilbert space of
dimension <span class="math notranslate nohighlight">\(2^N\)</span>. Thus the method is suitable only for
small N (of the order of 10).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.piqs.dicke_basis">
<code class="sig-name descname">dicke_basis</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">jmm1=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/piqs.html#dicke_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.piqs.dicke_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the density matrix of a Dicke state for several (j, m, m1).</p>
<p>This function can be used to build arbitrary states in the Dicke basis
<span class="math notranslate nohighlight">\(|j, m\rangle \langle j, m^{\prime}|\)</span>. We create coefficients for each
(j, m, m1) value in the dictionary jmm1. The mapping for the (i, k)
index of the density matrix to the <a href="#id45"><span class="problematic" id="id46">|</span></a>j, m&gt; values is given by the
cythonized function <cite>jmm1_dictionary</cite>. A density matrix is created from
the given dictionary of coefficients for each (j, m, m1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>jmm1: dict</strong></dt><dd><p>A dictionary of {(j, m, m1): p} that gives a density p for the
(j, m, m1) matrix element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>rho: :class: qutip.Qobj</dt><dd><p>The density matrix in the Dicke basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.wigner">
<span id="pseudoprobability-functions"></span><h3>Pseudoprobability Functions<a class="headerlink" href="#module-qutip.wigner" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.wigner.qfunc">
<code class="sig-name descname">qfunc</code><span class="sig-paren">(</span><em class="sig-param">state</em>, <em class="sig-param">xvec</em>, <em class="sig-param">yvec</em>, <em class="sig-param">g=1.4142135623730951</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#qfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.qfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Q-function of a given state vector or density matrix
at points <cite>xvec + i * yvec</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>A state vector or density matrix.</p>
</dd>
<dt><strong>xvec</strong><span class="classifier">array_like</span></dt><dd><p>x-coordinates at which to calculate the Wigner function.</p>
</dd>
<dt><strong>yvec</strong><span class="classifier">array_like</span></dt><dd><p>y-coordinates at which to calculate the Wigner function.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float</span></dt><dd><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">array</span></dt><dd><p>Values representing the Q-function calculated over the specified range
[xvec,yvec].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.spin_q_function">
<code class="sig-name descname">spin_q_function</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#spin_q_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.spin_q_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Husimi Q-function for spins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>A state vector or density matrix for a spin-j quantum system.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like</span></dt><dd><p>theta-coordinates at which to calculate the Q function.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array_like</span></dt><dd><p>phi-coordinates at which to calculate the Q function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Q, THETA, PHI</strong><span class="classifier">2d-array</span></dt><dd><p>Values representing the spin Q function at the values specified
by THETA and PHI.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.spin_wigner">
<code class="sig-name descname">spin_wigner</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#spin_wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.spin_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Wigner function for spins on the Bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>A state vector or density matrix for a spin-j quantum system.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like</span></dt><dd><p>theta-coordinates at which to calculate the Q function.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array_like</span></dt><dd><p>phi-coordinates at which to calculate the Q function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W, THETA, PHI</strong><span class="classifier">2d-array</span></dt><dd><p>Values representing the spin Wigner function at the values specified
by THETA and PHI.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Experimental.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.wigner">
<code class="sig-name descname">wigner</code><span class="sig-paren">(</span><em class="sig-param">psi</em>, <em class="sig-param">xvec</em>, <em class="sig-param">yvec</em>, <em class="sig-param">method='clenshaw'</em>, <em class="sig-param">g=1.4142135623730951</em>, <em class="sig-param">sparse=False</em>, <em class="sig-param">parfor=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Wigner function for a state vector or density matrix at points
<cite>xvec + i * yvec</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>A state vector or density matrix.</p>
</dd>
<dt><strong>xvec</strong><span class="classifier">array_like</span></dt><dd><p>x-coordinates at which to calculate the Wigner function.</p>
</dd>
<dt><strong>yvec</strong><span class="classifier">array_like</span></dt><dd><p>y-coordinates at which to calculate the Wigner function.  Does not
apply to the ‘fft’ method.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float</span></dt><dd><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}</span></dt><dd><p>Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’
and ‘iterative’ use an iterative method to evaluate the Wigner functions for density
matrices <span class="math notranslate nohighlight">\(|m&gt;&lt;n|\)</span>, while ‘laguerre’ uses the Laguerre polynomials
in scipy for the same task. The ‘fft’ method evaluates the Fourier
transform of the density matrix. The ‘iterative’ method is default, and
in general recommended, but the ‘laguerre’ method is more efficient for
very sparse density matrices (e.g., superpositions of Fock states in a
large Hilbert space). The ‘clenshaw’ method is the preferred method for
dealing with density matrices that have a large number of excitations
(&gt;~50). ‘clenshaw’ is a fast and numerically stable method.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Tells the default solver whether or not to keep the input density
matrix in sparse format.  As the dimensions of the density matrix
grow, setthing this flag can result in increased performance.</p>
</dd>
<dt><strong>parfor</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Flag for calculating the Laguerre polynomial based Wigner function
method=’laguerre’ in parallel using the parfor function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">array</span></dt><dd><p>Values representing the Wigner function calculated over the specified
range [xvec,yvec].</p>
</dd>
<dt><strong>yvex</strong><span class="classifier">array</span></dt><dd><p>FFT ONLY. Returns the y-coordinate values calculated via the Fourier
transform.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘fft’ method accepts only an xvec input for the x-coordinate.
The y-coordinates are calculated internally.</p>
<p class="rubric">References</p>
<p>Ulf Leonhardt,
Measuring the Quantum State of Light, (Cambridge University Press, 1997)</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.visualization">
<span id="graphs-and-visualization"></span><h3>Graphs and Visualization<a class="headerlink" href="#module-qutip.visualization" title="Permalink to this headline">¶</a></h3>
<p>Functions for visualizing results of quantum dynamics simulations,
visualizations of quantum states and processes.</p>
<dl class="function">
<dt id="qutip.visualization.hinton">
<code class="sig-name descname">hinton</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">xlabels=None</em>, <em class="sig-param">ylabels=None</em>, <em class="sig-param">title=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">cmap=None</em>, <em class="sig-param">label_top=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#hinton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.hinton" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a Hinton diagram for visualizing a density matrix or superoperator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Input density matrix or superoperator.</p>
</dd>
<dt><strong>xlabels</strong><span class="classifier">list of strings or False</span></dt><dd><p>list of x labels</p>
</dd>
<dt><strong>ylabels</strong><span class="classifier">list of strings or False</span></dt><dd><p>list of y labels</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>title of the plot (optional)</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib colormap instance</span></dt><dd><p>Color map to use when plotting.</p>
</dd>
<dt><strong>label_top</strong><span class="classifier">bool</span></dt><dd><p>If True, x-axis labels will be placed on top, otherwise
they will appear below the plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not a quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.matrix_histogram">
<code class="sig-name descname">matrix_histogram</code><span class="sig-paren">(</span><em class="sig-param">M</em>, <em class="sig-param">xlabels=None</em>, <em class="sig-param">ylabels=None</em>, <em class="sig-param">title=None</em>, <em class="sig-param">limits=None</em>, <em class="sig-param">colorbar=True</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#matrix_histogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the matrix M, with the given x and y labels and title.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">Matrix of Qobj</span></dt><dd><p>The matrix to visualize</p>
</dd>
<dt><strong>xlabels</strong><span class="classifier">list of strings</span></dt><dd><p>list of x labels</p>
</dd>
<dt><strong>ylabels</strong><span class="classifier">list of strings</span></dt><dd><p>list of y labels</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>title of the plot (optional)</p>
</dd>
<dt><strong>limits</strong><span class="classifier">list/array with two float numbers</span></dt><dd><p>The z-axis limits [min, max] (optional)</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not valid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.matrix_histogram_complex">
<code class="sig-name descname">matrix_histogram_complex</code><span class="sig-paren">(</span><em class="sig-param">M</em>, <em class="sig-param">xlabels=None</em>, <em class="sig-param">ylabels=None</em>, <em class="sig-param">title=None</em>, <em class="sig-param">limits=None</em>, <em class="sig-param">phase_limits=None</em>, <em class="sig-param">colorbar=True</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">threshold=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#matrix_histogram_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the amplitudes of matrix M, using the argument
of each element for coloring the bars, with the given x and y labels
and title.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">Matrix of Qobj</span></dt><dd><p>The matrix to visualize</p>
</dd>
<dt><strong>xlabels</strong><span class="classifier">list of strings</span></dt><dd><p>list of x labels</p>
</dd>
<dt><strong>ylabels</strong><span class="classifier">list of strings</span></dt><dd><p>list of y labels</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>title of the plot (optional)</p>
</dd>
<dt><strong>limits</strong><span class="classifier">list/array with two float numbers</span></dt><dd><p>The z-axis limits [min, max] (optional)</p>
</dd>
<dt><strong>phase_limits</strong><span class="classifier">list/array with two float numbers</span></dt><dd><p>The phase-axis (colorbar) limits [min, max] (optional)</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>threshold: float (None)</strong></dt><dd><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not valid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_energy_levels">
<code class="sig-name descname">plot_energy_levels</code><span class="sig-paren">(</span><em class="sig-param">H_list</em>, <em class="sig-param">N=0</em>, <em class="sig-param">labels=None</em>, <em class="sig-param">show_ylabels=False</em>, <em class="sig-param">figsize=(8</em>, <em class="sig-param">12)</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_energy_levels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_energy_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the energy level diagrams for a list of Hamiltonians. Include
up to N energy levels. For each element in H_list, the energy
levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,
where n is the index of an element in H_list.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H_list</strong><span class="classifier">List of Qobj</span></dt><dd><blockquote>
<div><p>A list of Hamiltonians.</p>
</div></blockquote>
<dl class="simple">
<dt>labels<span class="classifier">List of string</span></dt><dd><p>A list of labels for each Hamiltonian</p>
</dd>
<dt>show_ylabels<span class="classifier">Bool (default False)</span></dt><dd><p>Show y labels to the left of energy levels of the initial
Hamiltonian.</p>
</dd>
<dt>N<span class="classifier">int</span></dt><dd><p>The number of energy levels to plot</p>
</dd>
<dt>figsize<span class="classifier">tuple (int,int)</span></dt><dd><p>The size of the figure (width, height).</p>
</dd>
<dt>fig<span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt>ax<span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not valid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_fock_distribution">
<code class="sig-name descname">plot_fock_distribution</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">offset=0</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">figsize=(8</em>, <em class="sig-param">6)</em>, <em class="sig-param">title=None</em>, <em class="sig-param">unit_y_range=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_fock_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution for a density matrix (or ket) that describes
an oscillator mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt><dd><p>The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>An optional title for the figure.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_wigner_fock_distribution">
<code class="sig-name descname">plot_wigner_fock_distribution</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">axes=None</em>, <em class="sig-param">figsize=(8</em>, <em class="sig-param">4)</em>, <em class="sig-param">cmap=None</em>, <em class="sig-param">alpha_max=7.5</em>, <em class="sig-param">colorbar=False</em>, <em class="sig-param">method='iterative'</em>, <em class="sig-param">projection='2d'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_wigner_fock_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_wigner_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution and the Wigner function for a density matrix
(or ket) that describes an oscillator mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt><dd><p>The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">a list of two matplotlib axes instances</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib cmap instance</span></dt><dd><p>The colormap.</p>
</dd>
<dt><strong>alpha_max</strong><span class="classifier">float</span></dt><dd><p>The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘iterative’, ‘laguerre’, ‘fft’}</span></dt><dd><p>The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</dd>
<dt><strong>projection: string {‘2d’, ‘3d’}</strong></dt><dd><p>Specify whether the Wigner function is to be plotted as a
contour graph (‘2d’) or surface plot (‘3d’).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_wigner">
<code class="sig-name descname">plot_wigner</code><span class="sig-paren">(</span><em class="sig-param">rho</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">figsize=(6</em>, <em class="sig-param">6)</em>, <em class="sig-param">cmap=None</em>, <em class="sig-param">alpha_max=7.5</em>, <em class="sig-param">colorbar=False</em>, <em class="sig-param">method='clenshaw'</em>, <em class="sig-param">projection='2d'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the the Wigner function for a density matrix (or ket) that describes
an oscillator mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt><dd><p>The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib cmap instance</span></dt><dd><p>The colormap.</p>
</dd>
<dt><strong>alpha_max</strong><span class="classifier">float</span></dt><dd><p>The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}</span></dt><dd><p>The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</dd>
<dt><strong>projection: string {‘2d’, ‘3d’}</strong></dt><dd><p>Specify whether the Wigner function is to be plotted as a
contour graph (‘2d’) or surface plot (‘3d’).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.sphereplot">
<code class="sig-name descname">sphereplot</code><span class="sig-paren">(</span><em class="sig-param">theta</em>, <em class="sig-param">phi</em>, <em class="sig-param">values</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">save=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#sphereplot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.sphereplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Angle with respect to z-axis</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float</span></dt><dd><p>Angle in x-y plane</p>
</dd>
<dt><strong>values</strong><span class="classifier">array</span></dt><dd><p>Data set to be plotted</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>save</strong><span class="classifier">bool {False , True}</span></dt><dd><p>Whether to save the figure or not</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_schmidt">
<code class="sig-name descname">plot_schmidt</code><span class="sig-paren">(</span><em class="sig-param">ket</em>, <em class="sig-param">splitting=None</em>, <em class="sig-param">labels_iteration=(3</em>, <em class="sig-param">2)</em>, <em class="sig-param">theme='light'</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">figsize=(6</em>, <em class="sig-param">6)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_schmidt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_schmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Plotting scheme related to Schmidt decomposition.
Converts a state into a matrix (A_ij -&gt; A_i^j),
where rows are first particles and columns - last.</p>
<p>See also: plot_qubism with how=’before_after’ for a similar plot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">Qobj</span></dt><dd><p>Pure state for plotting.</p>
</dd>
<dt><strong>splitting</strong><span class="classifier">int</span></dt><dd><p>Plot for a number of first particles versus the rest.
If not given, it is (number of particles + 1) // 2.</p>
</dd>
<dt><strong>theme</strong><span class="classifier">‘light’ (default) or ‘dark’</span></dt><dd><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</dd>
<dt><strong>labels_iteration</strong><span class="classifier">int or pair of ints (default (3,2))</span></dt><dd><p>Number of particles to be shown as tick labels,
for first (vertical) and last (horizontal) particles, respectively.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_qubism">
<code class="sig-name descname">plot_qubism</code><span class="sig-paren">(</span><em class="sig-param">ket</em>, <em class="sig-param">theme='light'</em>, <em class="sig-param">how='pairs'</em>, <em class="sig-param">grid_iteration=1</em>, <em class="sig-param">legend_iteration=0</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">figsize=(6</em>, <em class="sig-param">6)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_qubism"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_qubism" title="Permalink to this definition">¶</a></dt>
<dd><p>Qubism plot for pure states of many qudits.
Works best for spin chains, especially with even number of particles
of the same dimension.
Allows to see entanglement between first 2*k particles and the rest.</p>
<p>More information:</p>
<blockquote>
<div><p>J. Rodriguez-Laguna, P. Migdal,
M. Ibanez Berganza, M. Lewenstein, G. Sierra,
“Qubism: self-similar visualization of many-body wavefunctions”,
New J. Phys. 14 053028 (2012), arXiv:1112.3560,
http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access)</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ket</strong><span class="classifier">Qobj</span></dt><dd><p>Pure state for plotting.</p>
</dd>
<dt><strong>theme</strong><span class="classifier">‘light’ (default) or ‘dark’</span></dt><dd><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</dd>
<dt><strong>how</strong><span class="classifier">‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’</span></dt><dd><p>Type of Qubism plotting.
Options:</p>
<blockquote>
<div><p>‘pairs’ - typical coordinates,
‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,
‘before_after’ - related to Schmidt plot (see also: plot_schmidt).</p>
</div></blockquote>
</dd>
<dt><strong>grid_iteration</strong><span class="classifier">int (default 1)</span></dt><dd><p>Helper lines to be drawn on plot.
Show tiles for 2*grid_iteration particles vs all others.</p>
</dd>
<dt><strong>legend_iteration</strong><span class="classifier">int (default 0) or ‘grid_iteration’ or ‘all’</span></dt><dd><p>Show labels for first 2*legend_iteration particles.
Option ‘grid_iteration’ sets the same number of particles</p>
<blockquote>
<div><p>as for grid_iteration.</p>
</div></blockquote>
<p>Option ‘all’ makes label for all particles.
Typically it should be 0, 1, 2 or perhaps 3.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_expectation_values">
<code class="sig-name descname">plot_expectation_values</code><span class="sig-paren">(</span><em class="sig-param">results</em>, <em class="sig-param">ylabels=[]</em>, <em class="sig-param">title=None</em>, <em class="sig-param">show_legend=False</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">axes=None</em>, <em class="sig-param">figsize=(8</em>, <em class="sig-param">4)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_expectation_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_expectation_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the results (expectation values) for an evolution solver.
<cite>results</cite> is assumed to be an instance of Result, or a list of Result
instances.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>results</strong><span class="classifier">(list of) <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt><dd><p>List of results objects returned by any of the QuTiP evolution solvers.</p>
</dd>
<dt><strong>ylabels</strong><span class="classifier">list of strings</span></dt><dd><p>The y-axis labels. List should be of the same length as <cite>results</cite>.</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>The title of the figure.</p>
</dd>
<dt><strong>show_legend</strong><span class="classifier">bool</span></dt><dd><p>Whether or not to show the legend.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_spin_distribution_2d">
<code class="sig-name descname">plot_spin_distribution_2d</code><span class="sig-paren">(</span><em class="sig-param">P</em>, <em class="sig-param">THETA</em>, <em class="sig-param">PHI</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">figsize=(8</em>, <em class="sig-param">8)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_spin_distribution_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a spin distribution function (given as meshgrid data) with a 2D
projection where the surface of the unit sphere is mapped on the unit disk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>P</strong><span class="classifier">matrix</span></dt><dd><p>Distribution values as a meshgrid matrix.</p>
</dd>
<dt><strong>THETA</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the theta coordinate.</p>
</dd>
<dt><strong>PHI</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the phi coordinate.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_spin_distribution_3d">
<code class="sig-name descname">plot_spin_distribution_3d</code><span class="sig-paren">(</span><em class="sig-param">P</em>, <em class="sig-param">THETA</em>, <em class="sig-param">PHI</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">figsize=(8</em>, <em class="sig-param">6)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_spin_distribution_3d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>P</strong><span class="classifier">matrix</span></dt><dd><p>Distribution values as a meshgrid matrix.</p>
</dd>
<dt><strong>THETA</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the theta coordinate.</p>
</dd>
<dt><strong>PHI</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the phi coordinate.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-qutip.orbital"></span><dl class="function">
<dt id="qutip.orbital.orbital">
<code class="sig-name descname">orbital</code><span class="sig-paren">(</span><em class="sig-param">theta</em>, <em class="sig-param">phi</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/orbital.html#orbital"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.orbital.orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates an angular wave function on a sphere.
<code class="docutils literal notranslate"><span class="pre">psi</span> <span class="pre">=</span> <span class="pre">orbital(theta,phi,ket1,ket2,...)</span></code> calculates
the angular wave function on a sphere at the mesh of points
defined by theta and phi which is
<span class="math notranslate nohighlight">\(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\)</span> where <span class="math notranslate nohighlight">\(C_{lm}\)</span> are the
coefficients specified by the list of kets. Each ket has 2l+1 components
for some integer l.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">list/array</span></dt><dd><p>Polar angles</p>
</dd>
<dt><strong>phi</strong><span class="classifier">list/array</span></dt><dd><p>Azimuthal angles</p>
</dd>
<dt><strong>args</strong><span class="classifier">list/array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of ket vectors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">array</span></code> for angular wave function</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.tomography">
<span id="quantum-process-tomography"></span><h3>Quantum Process Tomography<a class="headerlink" href="#module-qutip.tomography" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.tomography.qpt">
<code class="sig-name descname">qpt</code><span class="sig-paren">(</span><em class="sig-param">U</em>, <em class="sig-param">op_basis_list</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tomography.html#qpt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quantum process tomography chi matrix for a given (possibly
nonunitary) transformation matrix U, which transforms a density matrix in
vector form according to:</p>
<blockquote>
<div><p>vec(rho) = U * vec(rho0)</p>
<p>or</p>
<p>rho = vec2mat(U * mat2vec(rho0))</p>
</div></blockquote>
<p>U can be calculated for an open quantum system using the QuTiP propagator
function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>Transformation operator. Can be calculated using QuTiP propagator
function.</p>
</dd>
<dt><strong>op_basis_list</strong><span class="classifier">list</span></dt><dd><p>A list of Qobj’s representing the basis states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">array</span></dt><dd><p>QPT chi matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.tomography.qpt_plot">
<code class="sig-name descname">qpt_plot</code><span class="sig-paren">(</span><em class="sig-param">chi</em>, <em class="sig-param">lbls_list</em>, <em class="sig-param">title=None</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tomography.html#qpt_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot the real and
imaginary parts separately.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">array</span></dt><dd><p>Input QPT chi matrix.</p>
</dd>
<dt><strong>lbls_list</strong><span class="classifier">list</span></dt><dd><p>List of labels for QPT plot axes.</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>Plot title.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">figure instance</span></dt><dd><p>User defined figure instance used for generating QPT plot.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">list of figure axis instance</span></dt><dd><p>User defined figure axis instance (list of two axes) used for
generating QPT plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.tomography.qpt_plot_combined">
<code class="sig-name descname">qpt_plot_combined</code><span class="sig-paren">(</span><em class="sig-param">chi</em>, <em class="sig-param">lbls_list</em>, <em class="sig-param">title=None</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">figsize=(8</em>, <em class="sig-param">6)</em>, <em class="sig-param">threshold=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tomography.html#qpt_plot_combined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt_plot_combined" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot bars with
height and color corresponding to the absolute value and phase,
respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">array</span></dt><dd><p>Input QPT chi matrix.</p>
</dd>
<dt><strong>lbls_list</strong><span class="classifier">list</span></dt><dd><p>List of labels for QPT plot axes.</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>Plot title.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">figure instance</span></dt><dd><p>User defined figure instance used for generating QPT plot.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">figure axis instance</span></dt><dd><p>User defined figure axis instance used for generating QPT plot
(alternative to the fig argument).</p>
</dd>
<dt><strong>threshold: float (None)</strong></dt><dd><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="quantum-information-processing">
<span id="functions-qip"></span><h2>Quantum Information Processing<a class="headerlink" href="#quantum-information-processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.qip.gates">
<span id="gates"></span><h3>Gates<a class="headerlink" href="#module-qutip.qip.gates" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.gates.rx">
<code class="sig-name descname">rx</code><span class="sig-paren">(</span><em class="sig-param">phi</em>, <em class="sig-param">N=None</em>, <em class="sig-param">target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#rx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmax with angle phi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.ry">
<code class="sig-name descname">ry</code><span class="sig-paren">(</span><em class="sig-param">phi</em>, <em class="sig-param">N=None</em>, <em class="sig-param">target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#ry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.ry" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmay with angle phi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.rz">
<code class="sig-name descname">rz</code><span class="sig-paren">(</span><em class="sig-param">phi</em>, <em class="sig-param">N=None</em>, <em class="sig-param">target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#rz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rz" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmaz with angle phi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtnot">
<code class="sig-name descname">sqrtnot</code><span class="sig-paren">(</span><em class="sig-param">N=None</em>, <em class="sig-param">target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#sqrtnot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit square root NOT gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object for operator describing the square root NOT gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.snot">
<code class="sig-name descname">snot</code><span class="sig-paren">(</span><em class="sig-param">N=None</em>, <em class="sig-param">target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#snot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.snot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SNOT (Hadamard) gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>snot_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of SNOT gate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">snot</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.j  0.70710678+0.j]</span>
<span class="go"> [ 0.70710678+0.j -0.70710678+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.phasegate">
<code class="sig-name descname">phasegate</code><span class="sig-paren">(</span><em class="sig-param">theta</em>, <em class="sig-param">N=None</em>, <em class="sig-param">target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#phasegate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.phasegate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the phase shift gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Phase rotation angle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phase_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of phase shift gate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j          0.00000000+0.j        ]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.cphase">
<code class="sig-name descname">cphase</code><span class="sig-paren">(</span><em class="sig-param">theta</em>, <em class="sig-param">N=2</em>, <em class="sig-param">control=0</em>, <em class="sig-param">target=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#cphase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.cphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the controlled phase shift gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Phase rotation angle.</p>
</dd>
<dt><strong>N</strong><span class="classifier">integer</span></dt><dd><p>The number of qubits in the target space.</p>
</dd>
<dt><strong>control</strong><span class="classifier">integer</span></dt><dd><p>The index of the control qubit.</p>
</dd>
<dt><strong>target</strong><span class="classifier">integer</span></dt><dd><p>The index of the target qubit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>U</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of controlled phase gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.cnot">
<code class="sig-name descname">cnot</code><span class="sig-paren">(</span><em class="sig-param">N=None</em>, <em class="sig-param">control=0</em>, <em class="sig-param">target=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#cnot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.cnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CNOT gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cnot_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of CNOT gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnot</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.csign">
<code class="sig-name descname">csign</code><span class="sig-paren">(</span><em class="sig-param">N=None</em>, <em class="sig-param">control=0</em>, <em class="sig-param">target=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#csign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.csign" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CSIGN gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>csign_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of CSIGN gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">csign</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  -1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.berkeley">
<code class="sig-name descname">berkeley</code><span class="sig-paren">(</span><em class="sig-param">N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#berkeley"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.berkeley" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Berkeley gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>berkeley_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of Berkeley gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">berkeley</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ cos(pi/8).+0.j  0.+0.j           0.+0.j           0.+sin(pi/8).j]</span>
<span class="go">     [ 0.+0.j          cos(3pi/8).+0.j  0.+sin(3pi/8).j  0.+0.j]</span>
<span class="go">     [ 0.+0.j          0.+sin(3pi/8).j  cos(3pi/8).+0.j  0.+0.j]</span>
<span class="go">     [ 0.+sin(pi/8).j  0.+0.j           0.+0.j           cos(pi/8).+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.swapalpha">
<code class="sig-name descname">swapalpha</code><span class="sig-paren">(</span><em class="sig-param">alpha, N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#swapalpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.swapalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAPalpha gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>swapalpha_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of SWAPalpha gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">swapalpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j                    0.+0.j                    0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 + exp(j*pi*alpha)  0.5*(1 - exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 - exp(j*pi*alpha)  0.5*(1 + exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j                    0.+0.j                    1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.swap">
<code class="sig-name descname">swap</code><span class="sig-paren">(</span><em class="sig-param">N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#swap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAP gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>swap_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of SWAP gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">swap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.iswap">
<code class="sig-name descname">iswap</code><span class="sig-paren">(</span><em class="sig-param">N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#iswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.iswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the iSWAP gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>iswap_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of iSWAP gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iswap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+1.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+1.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtswap">
<code class="sig-name descname">sqrtswap</code><span class="sig-paren">(</span><em class="sig-param">N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#sqrtswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root SWAP gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sqrtswap_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of square root SWAP gate</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtiswap">
<code class="sig-name descname">sqrtiswap</code><span class="sig-paren">(</span><em class="sig-param">N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#sqrtiswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtiswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root iSWAP gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sqrtiswap_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of square root iSWAP gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sqrtiswap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j   0.00000000+0.j          0.00000000+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.70710678+0.j          0.00000000-0.70710678j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000-0.70710678j       0.70710678+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000+0.j          0.00000000+0.j          1.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.fredkin">
<code class="sig-name descname">fredkin</code><span class="sig-paren">(</span><em class="sig-param">N=None, control=0, targets=[1, 2]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#fredkin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.fredkin" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Fredkin gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fredkin_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of Fredkin gate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fredkin</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.toffoli">
<code class="sig-name descname">toffoli</code><span class="sig-paren">(</span><em class="sig-param">N=None, controls=[0, 1], target=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#toffoli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.toffoli" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Toffoli gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>toff_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of Toffoli gate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">toffoli</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.rotation">
<code class="sig-name descname">rotation</code><span class="sig-paren">(</span><em class="sig-param">op</em>, <em class="sig-param">phi</em>, <em class="sig-param">N=None</em>, <em class="sig-param">target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator op with angle phi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.controlled_gate">
<code class="sig-name descname">controlled_gate</code><span class="sig-paren">(</span><em class="sig-param">U</em>, <em class="sig-param">N=2</em>, <em class="sig-param">control=0</em>, <em class="sig-param">target=1</em>, <em class="sig-param">control_value=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#controlled_gate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.controlled_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an N-qubit controlled gate from a single-qubit gate U with the given
control and target qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>Arbitrary single-qubit gate.</p>
</dd>
<dt><strong>N</strong><span class="classifier">integer</span></dt><dd><p>The number of qubits in the target space.</p>
</dd>
<dt><strong>control</strong><span class="classifier">integer</span></dt><dd><p>The index of the first control qubit.</p>
</dd>
<dt><strong>target</strong><span class="classifier">integer</span></dt><dd><p>The index of the target qubit.</p>
</dd>
<dt><strong>control_value</strong><span class="classifier">integer (1)</span></dt><dd><p>The state of the control qubit that activates the gate U.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representing the controlled-U gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.globalphase">
<code class="sig-name descname">globalphase</code><span class="sig-paren">(</span><em class="sig-param">theta</em>, <em class="sig-param">N=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#globalphase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.globalphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the global phase shift gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Phase rotation angle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phase_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of global phase shift gate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.70710678j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.hadamard_transform">
<code class="sig-name descname">hadamard_transform</code><span class="sig-paren">(</span><em class="sig-param">N=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#hadamard_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.hadamard_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the N-qubit Hadamard gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of the N-qubit Hadamard gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_sequence_product">
<code class="sig-name descname">gate_sequence_product</code><span class="sig-paren">(</span><em class="sig-param">U_list</em>, <em class="sig-param">left_to_right=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_sequence_product"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_sequence_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the overall unitary matrix for a given list of unitary operations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U_list</strong><span class="classifier">list</span></dt><dd><p>List of gates implementing the quantum circuit.</p>
</dd>
<dt><strong>left_to_right</strong><span class="classifier">Boolean</span></dt><dd><p>Check if multiplication is to be done from left to right.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>U_overall</strong><span class="classifier">qobj</span></dt><dd><p>Overall unitary matrix of a given quantum circuit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_1toN">
<code class="sig-name descname">gate_expand_1toN</code><span class="sig-paren">(</span><em class="sig-param">U</em>, <em class="sig-param">N</em>, <em class="sig-param">target</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_expand_1toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_1toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a one-qubit gate that act on a system with N
qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>The one-qubit gate</p>
</dd>
<dt><strong>N</strong><span class="classifier">integer</span></dt><dd><p>The number of qubits in the target space.</p>
</dd>
<dt><strong>target</strong><span class="classifier">integer</span></dt><dd><p>The index of the target qubit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of N-qubit gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_2toN">
<code class="sig-name descname">gate_expand_2toN</code><span class="sig-paren">(</span><em class="sig-param">U</em>, <em class="sig-param">N</em>, <em class="sig-param">control=None</em>, <em class="sig-param">target=None</em>, <em class="sig-param">targets=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_expand_2toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_2toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a two-qubit gate that act on a system with N
qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>The two-qubit gate</p>
</dd>
<dt><strong>N</strong><span class="classifier">integer</span></dt><dd><p>The number of qubits in the target space.</p>
</dd>
<dt><strong>control</strong><span class="classifier">integer</span></dt><dd><p>The index of the control qubit.</p>
</dd>
<dt><strong>target</strong><span class="classifier">integer</span></dt><dd><p>The index of the target qubit.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">list</span></dt><dd><p>List of target qubits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of N-qubit gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_3toN">
<code class="sig-name descname">gate_expand_3toN</code><span class="sig-paren">(</span><em class="sig-param">U, N, controls=[0, 1], target=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_expand_3toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_3toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a three-qubit gate that act on a system with N
qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>The three-qubit gate</p>
</dd>
<dt><strong>N</strong><span class="classifier">integer</span></dt><dd><p>The number of qubits in the target space.</p>
</dd>
<dt><strong>controls</strong><span class="classifier">list</span></dt><dd><p>The list of the control qubits.</p>
</dd>
<dt><strong>target</strong><span class="classifier">integer</span></dt><dd><p>The index of the target qubit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of N-qubit gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.qubits">
<span id="qubits"></span><h3>Qubits<a class="headerlink" href="#module-qutip.qip.qubits" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.qubits.qubit_states">
<code class="sig-name descname">qubit_states</code><span class="sig-paren">(</span><em class="sig-param">N=1, states=[0]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/qubits.html#qubit_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.qubits.qubit_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to define initial state of the qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">Integer</span></dt><dd><p>Number of qubits in the register.</p>
</dd>
<dt><strong>states</strong><span class="classifier">List</span></dt><dd><p>Initial state of each qubit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qstates</strong><span class="classifier">Qobj</span></dt><dd><p>List of qubits.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.algorithms.qft">
<span id="algorithms"></span><h3>Algorithms<a class="headerlink" href="#module-qutip.qip.algorithms.qft" title="Permalink to this headline">¶</a></h3>
<p>This module provides the circuit implementation for Quantum Fourier Transform.</p>
<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft">
<code class="sig-name descname">qft</code><span class="sig-paren">(</span><em class="sig-param">N=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/algorithms/qft.html#qft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of qubits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>QFT: qobj</dt><dd><p>Quantum Fourier transform operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft_steps">
<code class="sig-name descname">qft_steps</code><span class="sig-paren">(</span><em class="sig-param">N=1</em>, <em class="sig-param">swapping=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/algorithms/qft.html#qft_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the individual
steps as unitary matrices operating from left to right.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>Number of qubits.</p>
</dd>
<dt><strong>swap: boolean</strong></dt><dd><p>Flag indicating sequence of swap gates to be applied at the end or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_step_list: list of qobj</dt><dd><p>List of Hadamard and controlled rotation gates implementing QFT.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft_gate_sequence">
<code class="sig-name descname">qft_gate_sequence</code><span class="sig-paren">(</span><em class="sig-param">N=1</em>, <em class="sig-param">swapping=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/algorithms/qft.html#qft_gate_sequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_gate_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the gate sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>Number of qubits.</p>
</dd>
<dt><strong>swap: boolean</strong></dt><dd><p>Flag indicating sequence of swap gates to be applied at the end or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qc: instance of QubitCircuit</dt><dd><p>Gate sequence of Hadamard and controlled rotation gates implementing
QFT.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-qutip.nonmarkov.transfertensor">
<span id="non-markovian-solvers"></span><span id="functions-non-markov"></span><h2>Non-Markovian Solvers<a class="headerlink" href="#module-qutip.nonmarkov.transfertensor" title="Permalink to this headline">¶</a></h2>
<p>This module contains an implementation of the non-Markovian transfer tensor
method (TTM), introduced in [1].</p>
<p>[1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014)</p>
<dl class="function">
<dt id="qutip.nonmarkov.transfertensor.ttmsolve">
<code class="sig-name descname">ttmsolve</code><span class="sig-paren">(</span><em class="sig-param">dynmaps</em>, <em class="sig-param">rho0</em>, <em class="sig-param">times</em>, <em class="sig-param">e_ops=[]</em>, <em class="sig-param">learningtimes=None</em>, <em class="sig-param">tensors=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/transfertensor.html#ttmsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.transfertensor.ttmsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve time-evolution using the Transfer Tensor Method, based on a set of
precomputed dynamical maps.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>dynmaps</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>List of precomputed dynamical maps (superoperators),
or a callback function that returns the
superoperator at a given time.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier">array_like</span></dt><dd><p>list of times <span class="math notranslate nohighlight">\(t_n\)</span> at which to compute <span class="math notranslate nohighlight">\(\rho(t_n)\)</span>.
Must be uniformily spaced.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function</span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>learningtimes</strong><span class="classifier">array_like</span></dt><dd><p>list of times <span class="math notranslate nohighlight">\(t_k\)</span> for which we have knowledge of the dynamical
maps <span class="math notranslate nohighlight">\(E(t_k)\)</span>.</p>
</dd>
<dt><strong>tensors</strong><span class="classifier">array_like</span></dt><dd><p>optional list of precomputed tensors <span class="math notranslate nohighlight">\(T_k\)</span></p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dictionary</span></dt><dd><p>Optional keyword arguments. See
<code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.nonmarkov.ttm.TTMSolverOptions</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.control.pulseoptim">
<span id="optimal-control"></span><span id="functions-control"></span><h2>Optimal control<a class="headerlink" href="#module-qutip.control.pulseoptim" title="Permalink to this headline">¶</a></h2>
<p>Wrapper functions that will manage the creation of the objects,
build the configuration, and execute the algorithm required to optimise
a set of ctrl pulses for a given (quantum) system.
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.
The functions minimise this fidelity error wrt the piecewise control
amplitudes in the timeslots</p>
<p>There are currently two quantum control pulse optmisations algorithms
implemented in this library. There are accessible through the methods
in this module. Both the algorithms use the scipy.optimize methods
to minimise the fidelity error with respect to to variables that define
the pulse.</p>
<div class="section" id="grape">
<h3>GRAPE<a class="headerlink" href="#grape" title="Permalink to this headline">¶</a></h3>
<p>The default algorithm (as it was implemented here first) is GRAPE
GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such
as BFGS to minimise the fidelity error. This makes convergence very quick
when an exact gradient can be calculated, but this limits the factors that can
taken into account in the fidelity.</p>
</div>
<div class="section" id="crab">
<h3>CRAB<a class="headerlink" href="#crab" title="Permalink to this headline">¶</a></h3>
<p>The CRAB [3][4] algorithm was developed at the University of Ulm.
In full it is the Chopped RAndom Basis algorithm.
The main difference is that it reduces the number of optimisation variables
by defining the control pulses by expansions of basis functions,
where the variables are the coefficients. Typically a Fourier series is chosen,
i.e. the variables are the Fourier coefficients.
Therefore it does not need to compute an explicit gradient.
By default it uses the Nelder-Mead method for fidelity error minimisation.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>N Khaneja et. al.
Optimal control of coupled spin dynamics: Design of NMR pulse sequences
by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).</p></li>
<li><p>Shai Machnes et.al
DYNAMO - Dynamic Framework for Quantum Optimal Control
arXiv.1011.4874</p></li>
<li><p>Doria, P., Calarco, T. &amp; Montangero, S.
Optimal Control Technique for Many-Body Quantum Dynamics.
Phys. Rev. Lett. 106, 1–4 (2011).</p></li>
<li><p>Caneva, T., Calarco, T. &amp; Montangero, S.
Chopped random-basis quantum optimization.
Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011).</p></li>
</ol>
<dl class="function">
<dt id="qutip.control.pulseoptim.optimize_pulse">
<code class="sig-name descname">optimize_pulse</code><span class="sig-paren">(</span><em class="sig-param">drift</em>, <em class="sig-param">ctrls</em>, <em class="sig-param">initial</em>, <em class="sig-param">target</em>, <em class="sig-param">num_tslots=None</em>, <em class="sig-param">evo_time=None</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">amp_lbound=None</em>, <em class="sig-param">amp_ubound=None</em>, <em class="sig-param">fid_err_targ=1e-10</em>, <em class="sig-param">min_grad=1e-10</em>, <em class="sig-param">max_iter=500</em>, <em class="sig-param">max_wall_time=180</em>, <em class="sig-param">alg='GRAPE'</em>, <em class="sig-param">alg_params=None</em>, <em class="sig-param">optim_params=None</em>, <em class="sig-param">optim_method='DEF'</em>, <em class="sig-param">method_params=None</em>, <em class="sig-param">optim_alg=None</em>, <em class="sig-param">max_metric_corr=None</em>, <em class="sig-param">accuracy_factor=None</em>, <em class="sig-param">dyn_type='GEN_MAT'</em>, <em class="sig-param">dyn_params=None</em>, <em class="sig-param">prop_type='DEF'</em>, <em class="sig-param">prop_params=None</em>, <em class="sig-param">fid_type='DEF'</em>, <em class="sig-param">fid_params=None</em>, <em class="sig-param">phase_option=None</em>, <em class="sig-param">fid_err_scale_factor=None</em>, <em class="sig-param">tslot_type='DEF'</em>, <em class="sig-param">tslot_params=None</em>, <em class="sig-param">amp_update_mode=None</em>, <em class="sig-param">init_pulse_type='DEF'</em>, <em class="sig-param">init_pulse_params=None</em>, <em class="sig-param">pulse_scaling=1.0</em>, <em class="sig-param">pulse_offset=0.0</em>, <em class="sig-param">ramping_pulse_type=None</em>, <em class="sig-param">ramping_pulse_params=None</em>, <em class="sig-param">log_level=0</em>, <em class="sig-param">out_file_ext=None</em>, <em class="sig-param">gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#optimize_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.optimize_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error.
The dynamics of the system in any given timeslot are governed
by the combined dynamics generator,
i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]
The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes
Starting from an intital (typically random) pulse,
a multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>drift</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>the underlying dynamics generator of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>ctrls</strong><span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt><dd><p>a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>initial</strong><span class="classifier">Qobj</span></dt><dd><p>starting point for the evolution.
Typically the identity matrix</p>
</dd>
<dt><strong>target</strong><span class="classifier">Qobj</span></dt><dd><p>target transformation, e.g. gate or state, for the time evolution</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer or None</span></dt><dd><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float or None</span></dt><dd><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of floats or None</span></dt><dd><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</dd>
<dt><strong>mim_grad</strong><span class="classifier">float</span></dt><dd><p>Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</dd>
<dt><strong>alg</strong><span class="classifier">string</span></dt><dd><p>Algorithm to use in pulse optimisation.
Options are:</p>
<blockquote>
<div><p>‘GRAPE’ (default) - GRadient Ascent Pulse Engineering
‘CRAB’ - Chopped RAndom Basis</p>
</div></blockquote>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong><span class="classifier">Dictionary</span></dt><dd><p>The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error
Note that FMIN, FMIN_BFGS &amp; FMIN_L_BFGS_B will all result
in calling these specific scipy.optimize methods
Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards
capatibility reasons.
Supplying DEF will given alg dependent result:</p>
<blockquote>
<div><p>GRAPE - Default optim_method is FMIN_L_BFGS_B
CRAB - Default optim_method is FMIN</p>
</div></blockquote>
</dd>
<dt><strong>method_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the optim_method.
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key
that attribute. Otherwise, and in some case also,
they are assumed to be method_options
for the scipy.optimize.minimize method.</p>
</dd>
<dt><strong>optim_alg</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use optim_method.</p>
</dd>
<dt><strong>max_metric_corr</strong><span class="classifier">integer</span></dt><dd><p>Deprecated. Use method_params instead</p>
</dd>
<dt><strong>accuracy_factor</strong><span class="classifier">float</span></dt><dd><p>Deprecated. Use method_params instead</p>
</dd>
<dt><strong>dyn_type</strong><span class="classifier">string</span></dt><dd><p>Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</dd>
<dt><strong>dyn_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_type</strong><span class="classifier">string</span></dt><dd><p>Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</dd>
<dt><strong>prop_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_type</strong><span class="classifier">string</span></dt><dd><p>Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FidelityComputer classes for details)</p>
</dd>
<dt><strong>fid_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>phase_option</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Pass in fid_params instead.</p>
</dd>
<dt><strong>fid_err_scale_factor</strong><span class="classifier">float</span></dt><dd><p>Deprecated. Use scale_factor key in fid_params instead.</p>
</dd>
<dt><strong>tslot_type</strong><span class="classifier">string</span></dt><dd><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>amp_update_mode</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use tslot_type instead.</p>
</dd>
<dt><strong>init_pulse_type</strong><span class="classifier">string</span></dt><dd><p>type / shape of pulse(s) used to initialise the
the control amplitudes.
Options (GRAPE) include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW</p>
</div></blockquote>
<p>DEF is RND
(see PulseGen classes for details)
For the CRAB the this the guess_pulse_type.</p>
</dd>
<dt><strong>init_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the initial / guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>pulse_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for generated initial / guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset for the pulse. That is this value will be added
to any initial / guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>out_file_ext</strong><span class="classifier">string or None</span></dt><dd><p>files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</dd>
<dt><strong>gen_stats</strong><span class="classifier">boolean</span></dt><dd><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opt</strong><span class="classifier">OptimResult</span></dt><dd><p>Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.optimize_pulse_unitary">
<code class="sig-name descname">optimize_pulse_unitary</code><span class="sig-paren">(</span><em class="sig-param">H_d</em>, <em class="sig-param">H_c</em>, <em class="sig-param">U_0</em>, <em class="sig-param">U_targ</em>, <em class="sig-param">num_tslots=None</em>, <em class="sig-param">evo_time=None</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">amp_lbound=None</em>, <em class="sig-param">amp_ubound=None</em>, <em class="sig-param">fid_err_targ=1e-10</em>, <em class="sig-param">min_grad=1e-10</em>, <em class="sig-param">max_iter=500</em>, <em class="sig-param">max_wall_time=180</em>, <em class="sig-param">alg='GRAPE'</em>, <em class="sig-param">alg_params=None</em>, <em class="sig-param">optim_params=None</em>, <em class="sig-param">optim_method='DEF'</em>, <em class="sig-param">method_params=None</em>, <em class="sig-param">optim_alg=None</em>, <em class="sig-param">max_metric_corr=None</em>, <em class="sig-param">accuracy_factor=None</em>, <em class="sig-param">phase_option='PSU'</em>, <em class="sig-param">dyn_params=None</em>, <em class="sig-param">prop_params=None</em>, <em class="sig-param">fid_params=None</em>, <em class="sig-param">tslot_type='DEF'</em>, <em class="sig-param">tslot_params=None</em>, <em class="sig-param">amp_update_mode=None</em>, <em class="sig-param">init_pulse_type='DEF'</em>, <em class="sig-param">init_pulse_params=None</em>, <em class="sig-param">pulse_scaling=1.0</em>, <em class="sig-param">pulse_offset=0.0</em>, <em class="sig-param">ramping_pulse_type=None</em>, <em class="sig-param">ramping_pulse_params=None</em>, <em class="sig-param">log_level=0</em>, <em class="sig-param">out_file_ext=None</em>, <em class="sig-param">gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#optimize_pulse_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.optimize_pulse_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error, assuming that
the dynamics of the system are generated by unitary operators.
This function is simply a wrapper for optimize_pulse, where the
appropriate options for unitary dynamics are chosen and the parameter
names are in the format familiar to unitary dynamics
The dynamics of the system  in any given timeslot are governed
by the combined Hamiltonian,
i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]
The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes
Starting from an intital (typically random) pulse,
a multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The maximum fidelity for a unitary system is 1, i.e. when the
time evolution resulting from the pulse is equivalent to the target.
And therefore the fidelity error is 1 - fidelity</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H_d</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>Drift (aka system) the underlying Hamiltonian of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>H_c</strong><span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt><dd><p>a list of control Hamiltonians. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>U_0</strong><span class="classifier">Qobj</span></dt><dd><p>starting point for the evolution.
Typically the identity matrix</p>
</dd>
<dt><strong>U_targ</strong><span class="classifier">Qobj</span></dt><dd><p>target transformation, e.g. gate or state, for the time evolution</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer or None</span></dt><dd><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float or None</span></dt><dd><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of floats or None</span></dt><dd><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</dd>
<dt><strong>mim_grad</strong><span class="classifier">float</span></dt><dd><p>Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</dd>
<dt><strong>alg</strong><span class="classifier">string</span></dt><dd><p>Algorithm to use in pulse optimisation.
Options are:</p>
<blockquote>
<div><p>‘GRAPE’ (default) - GRadient Ascent Pulse Engineering
‘CRAB’ - Chopped RAndom Basis</p>
</div></blockquote>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong><span class="classifier">Dictionary</span></dt><dd><p>The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error
Note that FMIN, FMIN_BFGS &amp; FMIN_L_BFGS_B will all result
in calling these specific scipy.optimize methods
Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards
capatibility reasons.
Supplying DEF will given alg dependent result:</p>
<blockquote>
<div><p>GRAPE - Default optim_method is FMIN_L_BFGS_B
CRAB - Default optim_method is FMIN</p>
</div></blockquote>
</dd>
<dt><strong>method_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the optim_method.
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key
that attribute. Otherwise, and in some case also,
they are assumed to be method_options
for the scipy.optimize.minimize method.</p>
</dd>
<dt><strong>optim_alg</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use optim_method.</p>
</dd>
<dt><strong>max_metric_corr</strong><span class="classifier">integer</span></dt><dd><p>Deprecated. Use method_params instead</p>
</dd>
<dt><strong>accuracy_factor</strong><span class="classifier">float</span></dt><dd><p>Deprecated. Use method_params instead</p>
</dd>
<dt><strong>phase_option</strong><span class="classifier">string</span></dt><dd><p>determines how global phase is treated in fidelity
calculations (fid_type=’UNIT’ only). Options:</p>
<blockquote>
<div><p>PSU - global phase ignored
SU - global phase included</p>
</div></blockquote>
</dd>
<dt><strong>dyn_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>tslot_type</strong><span class="classifier">string</span></dt><dd><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>amp_update_mode</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use tslot_type instead.</p>
</dd>
<dt><strong>init_pulse_type</strong><span class="classifier">string</span></dt><dd><p>type / shape of pulse(s) used to initialise the
the control amplitudes.
Options (GRAPE) include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW
DEF is RND</p>
</div></blockquote>
<p>(see PulseGen classes for details)
For the CRAB the this the guess_pulse_type.</p>
</dd>
<dt><strong>init_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the initial / guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>pulse_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for generated initial / guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset for the pulse. That is this value will be added
to any initial / guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>out_file_ext</strong><span class="classifier">string or None</span></dt><dd><p>files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</dd>
<dt><strong>gen_stats</strong><span class="classifier">boolean</span></dt><dd><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opt</strong><span class="classifier">OptimResult</span></dt><dd><p>Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.create_pulse_optimizer">
<code class="sig-name descname">create_pulse_optimizer</code><span class="sig-paren">(</span><em class="sig-param">drift</em>, <em class="sig-param">ctrls</em>, <em class="sig-param">initial</em>, <em class="sig-param">target</em>, <em class="sig-param">num_tslots=None</em>, <em class="sig-param">evo_time=None</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">amp_lbound=None</em>, <em class="sig-param">amp_ubound=None</em>, <em class="sig-param">fid_err_targ=1e-10</em>, <em class="sig-param">min_grad=1e-10</em>, <em class="sig-param">max_iter=500</em>, <em class="sig-param">max_wall_time=180</em>, <em class="sig-param">alg='GRAPE'</em>, <em class="sig-param">alg_params=None</em>, <em class="sig-param">optim_params=None</em>, <em class="sig-param">optim_method='DEF'</em>, <em class="sig-param">method_params=None</em>, <em class="sig-param">optim_alg=None</em>, <em class="sig-param">max_metric_corr=None</em>, <em class="sig-param">accuracy_factor=None</em>, <em class="sig-param">dyn_type='GEN_MAT'</em>, <em class="sig-param">dyn_params=None</em>, <em class="sig-param">prop_type='DEF'</em>, <em class="sig-param">prop_params=None</em>, <em class="sig-param">fid_type='DEF'</em>, <em class="sig-param">fid_params=None</em>, <em class="sig-param">phase_option=None</em>, <em class="sig-param">fid_err_scale_factor=None</em>, <em class="sig-param">tslot_type='DEF'</em>, <em class="sig-param">tslot_params=None</em>, <em class="sig-param">amp_update_mode=None</em>, <em class="sig-param">init_pulse_type='DEF'</em>, <em class="sig-param">init_pulse_params=None</em>, <em class="sig-param">pulse_scaling=1.0</em>, <em class="sig-param">pulse_offset=0.0</em>, <em class="sig-param">ramping_pulse_type=None</em>, <em class="sig-param">ramping_pulse_params=None</em>, <em class="sig-param">log_level=0</em>, <em class="sig-param">gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#create_pulse_optimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.create_pulse_optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the objects of the appropriate subclasses
required for the pulse optmisation based on the parameters given
Note this method may be preferable to calling optimize_pulse
if more detailed configuration is required before running the
optmisation algorthim, or the algorithm will be run many times,
for instances when trying to finding global the optimum or
minimum time optimisation</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>drift</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>the underlying dynamics generator of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>ctrls</strong><span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt><dd><p>a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>initial</strong><span class="classifier">Qobj</span></dt><dd><p>starting point for the evolution.
Typically the identity matrix</p>
</dd>
<dt><strong>target</strong><span class="classifier">Qobj</span></dt><dd><p>target transformation, e.g. gate or state, for the time evolution</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer or None</span></dt><dd><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float or None</span></dt><dd><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of floats or None</span></dt><dd><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</dd>
<dt><strong>mim_grad</strong><span class="classifier">float</span></dt><dd><p>Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p>Maximum allowed elapsed time for the optimisation algorithm</p>
</dd>
<dt><strong>alg</strong><span class="classifier">string</span></dt><dd><p>Algorithm to use in pulse optimisation.
Options are:</p>
<blockquote>
<div><p>‘GRAPE’ (default) - GRadient Ascent Pulse Engineering
‘CRAB’ - Chopped RAndom Basis</p>
</div></blockquote>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong><span class="classifier">Dictionary</span></dt><dd><p>The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error
Note that FMIN, FMIN_BFGS &amp; FMIN_L_BFGS_B will all result
in calling these specific scipy.optimize methods
Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards
capatibility reasons.
Supplying DEF will given alg dependent result:</p>
<blockquote>
<div><ul class="simple">
<li><p>GRAPE - Default optim_method is FMIN_L_BFGS_B</p></li>
<li><p>CRAB - Default optim_method is Nelder-Mead</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>method_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the optim_method.
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key
that attribute. Otherwise, and in some case also,
they are assumed to be method_options
for the scipy.optimize.minimize method.</p>
</dd>
<dt><strong>optim_alg</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use optim_method.</p>
</dd>
<dt><strong>max_metric_corr</strong><span class="classifier">integer</span></dt><dd><p>Deprecated. Use method_params instead</p>
</dd>
<dt><strong>accuracy_factor</strong><span class="classifier">float</span></dt><dd><p>Deprecated. Use method_params instead</p>
</dd>
<dt><strong>dyn_type</strong><span class="classifier">string</span></dt><dd><p>Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</dd>
<dt><strong>dyn_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_type</strong><span class="classifier">string</span></dt><dd><p>Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</dd>
<dt><strong>prop_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_type</strong><span class="classifier">string</span></dt><dd><p>Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FidelityComputer classes for details)</p>
</dd>
<dt><strong>fid_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>phase_option</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Pass in fid_params instead.</p>
</dd>
<dt><strong>fid_err_scale_factor</strong><span class="classifier">float</span></dt><dd><p>Deprecated. Use scale_factor key in fid_params instead.</p>
</dd>
<dt><strong>tslot_type</strong><span class="classifier">string</span></dt><dd><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>amp_update_mode</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use tslot_type instead.</p>
</dd>
<dt><strong>init_pulse_type</strong><span class="classifier">string</span></dt><dd><p>type / shape of pulse(s) used to initialise the
the control amplitudes.
Options (GRAPE) include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW
DEF is RND</p>
</div></blockquote>
<p>(see PulseGen classes for details)
For the CRAB the this the guess_pulse_type.</p>
</dd>
<dt><strong>init_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the initial / guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>pulse_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for generated initial / guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset for the pulse. That is this value will be added
to any initial / guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>gen_stats</strong><span class="classifier">boolean</span></dt><dd><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opt</strong><span class="classifier">Optimizer</span></dt><dd><p>Instance of an Optimizer, through which the
Config, Dynamics, PulseGen, and TerminationConditions objects
can be accessed as attributes.
The PropagatorComputer, FidelityComputer and TimeslotComputer objects
can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer
The optimisation can be run through the optimizer.run_optimization</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.opt_pulse_crab">
<code class="sig-name descname">opt_pulse_crab</code><span class="sig-paren">(</span><em class="sig-param">drift</em>, <em class="sig-param">ctrls</em>, <em class="sig-param">initial</em>, <em class="sig-param">target</em>, <em class="sig-param">num_tslots=None</em>, <em class="sig-param">evo_time=None</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">amp_lbound=None</em>, <em class="sig-param">amp_ubound=None</em>, <em class="sig-param">fid_err_targ=1e-05</em>, <em class="sig-param">max_iter=500</em>, <em class="sig-param">max_wall_time=180</em>, <em class="sig-param">alg_params=None</em>, <em class="sig-param">num_coeffs=None</em>, <em class="sig-param">init_coeff_scaling=1.0</em>, <em class="sig-param">optim_params=None</em>, <em class="sig-param">optim_method='fmin'</em>, <em class="sig-param">method_params=None</em>, <em class="sig-param">dyn_type='GEN_MAT'</em>, <em class="sig-param">dyn_params=None</em>, <em class="sig-param">prop_type='DEF'</em>, <em class="sig-param">prop_params=None</em>, <em class="sig-param">fid_type='DEF'</em>, <em class="sig-param">fid_params=None</em>, <em class="sig-param">tslot_type='DEF'</em>, <em class="sig-param">tslot_params=None</em>, <em class="sig-param">guess_pulse_type=None</em>, <em class="sig-param">guess_pulse_params=None</em>, <em class="sig-param">guess_pulse_scaling=1.0</em>, <em class="sig-param">guess_pulse_offset=0.0</em>, <em class="sig-param">guess_pulse_action='MODULATE'</em>, <em class="sig-param">ramping_pulse_type=None</em>, <em class="sig-param">ramping_pulse_params=None</em>, <em class="sig-param">log_level=0</em>, <em class="sig-param">out_file_ext=None</em>, <em class="sig-param">gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#opt_pulse_crab"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.opt_pulse_crab" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error.
The dynamics of the system in any given timeslot are governed
by the combined dynamics generator,
i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]
The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.
The CRAB algorithm uses basis function coefficents as the variables to
optimise. It does NOT use any gradient function.
A multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>drift</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>the underlying dynamics generator of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>ctrls</strong><span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt><dd><p>a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>initial</strong><span class="classifier">Qobj</span></dt><dd><p>starting point for the evolution.
Typically the identity matrix</p>
</dd>
<dt><strong>target</strong><span class="classifier">Qobj</span></dt><dd><p>target transformation, e.g. gate or state, for the time evolution</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer or None</span></dt><dd><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float or None</span></dt><dd><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of floats or None</span></dt><dd><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong><span class="classifier">Dictionary</span></dt><dd><p>The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</dd>
<dt><strong>coeff_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for the random basis coefficients
By default these range from -1.0 to 1.0
Note this is overridden by alg_params (if given there)</p>
</dd>
<dt><strong>num_coeffs</strong><span class="classifier">integer</span></dt><dd><p>Number of coefficients used for each basis function
Note this is calculated automatically based on the dimension of the
dynamics if not given. It is crucial to the performane of the
algorithm that it is set as low as possible, while still giving
high enough frequencies.
Note this is overridden by alg_params (if given there)</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>Multi-variable optimisation method
The only tested options are ‘fmin’ and ‘Nelder-mead’
In theory any non-gradient method implemented in
scipy.optimize.mininize could be used.</p>
</dd>
<dt><strong>method_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the optim_method.
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key
that attribute. Otherwise, and in some case also,
they are assumed to be method_options
for the scipy.optimize.minimize method.
The commonly used parameter are:</p>
<blockquote>
<div><p>xtol - limit on variable change for convergence
ftol - limit on fidelity error change for convergence</p>
</div></blockquote>
</dd>
<dt><strong>dyn_type</strong><span class="classifier">string</span></dt><dd><p>Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</dd>
<dt><strong>dyn_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_type</strong><span class="classifier">string</span></dt><dd><p>Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</dd>
<dt><strong>prop_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_type</strong><span class="classifier">string</span></dt><dd><p>Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FidelityComputer classes for details)</p>
</dd>
<dt><strong>fid_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>tslot_type</strong><span class="classifier">string</span></dt><dd><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>guess_pulse_type</strong><span class="classifier">string</span></dt><dd><p>type / shape of pulse(s) used modulate the control amplitudes.
Options include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN</p>
</div></blockquote>
<p>Default is None</p>
</dd>
<dt><strong>guess_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>guess_pulse_action</strong><span class="classifier">string</span></dt><dd><p>Determines how the guess pulse is applied to the pulse generated
by the basis expansion.
Options are: MODULATE, ADD
Default is MODULATE</p>
</dd>
<dt><strong>pulse_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for generated guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset for the pulse. That is this value will be added
to any guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>out_file_ext</strong><span class="classifier">string or None</span></dt><dd><p>files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</dd>
<dt><strong>gen_stats</strong><span class="classifier">boolean</span></dt><dd><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opt</strong><span class="classifier">OptimResult</span></dt><dd><p>Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.opt_pulse_crab_unitary">
<code class="sig-name descname">opt_pulse_crab_unitary</code><span class="sig-paren">(</span><em class="sig-param">H_d</em>, <em class="sig-param">H_c</em>, <em class="sig-param">U_0</em>, <em class="sig-param">U_targ</em>, <em class="sig-param">num_tslots=None</em>, <em class="sig-param">evo_time=None</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">amp_lbound=None</em>, <em class="sig-param">amp_ubound=None</em>, <em class="sig-param">fid_err_targ=1e-05</em>, <em class="sig-param">max_iter=500</em>, <em class="sig-param">max_wall_time=180</em>, <em class="sig-param">alg_params=None</em>, <em class="sig-param">num_coeffs=None</em>, <em class="sig-param">init_coeff_scaling=1.0</em>, <em class="sig-param">optim_params=None</em>, <em class="sig-param">optim_method='fmin'</em>, <em class="sig-param">method_params=None</em>, <em class="sig-param">phase_option='PSU'</em>, <em class="sig-param">dyn_params=None</em>, <em class="sig-param">prop_params=None</em>, <em class="sig-param">fid_params=None</em>, <em class="sig-param">tslot_type='DEF'</em>, <em class="sig-param">tslot_params=None</em>, <em class="sig-param">guess_pulse_type=None</em>, <em class="sig-param">guess_pulse_params=None</em>, <em class="sig-param">guess_pulse_scaling=1.0</em>, <em class="sig-param">guess_pulse_offset=0.0</em>, <em class="sig-param">guess_pulse_action='MODULATE'</em>, <em class="sig-param">ramping_pulse_type=None</em>, <em class="sig-param">ramping_pulse_params=None</em>, <em class="sig-param">log_level=0</em>, <em class="sig-param">out_file_ext=None</em>, <em class="sig-param">gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#opt_pulse_crab_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.opt_pulse_crab_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error, assuming that
the dynamics of the system are generated by unitary operators.
This function is simply a wrapper for optimize_pulse, where the
appropriate options for unitary dynamics are chosen and the parameter
names are in the format familiar to unitary dynamics
The dynamics of the system  in any given timeslot are governed
by the combined Hamiltonian,
i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]
The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes</p>
<p>The CRAB algorithm uses basis function coefficents as the variables to
optimise. It does NOT use any gradient function.
A multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H_d</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>Drift (aka system) the underlying Hamiltonian of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>H_c</strong><span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt><dd><p>a list of control Hamiltonians. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>U_0</strong><span class="classifier">Qobj</span></dt><dd><p>starting point for the evolution.
Typically the identity matrix</p>
</dd>
<dt><strong>U_targ</strong><span class="classifier">Qobj</span></dt><dd><p>target transformation, e.g. gate or state, for the time evolution</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer or None</span></dt><dd><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float or None</span></dt><dd><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of floats or None</span></dt><dd><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong><span class="classifier">Dictionary</span></dt><dd><p>The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</dd>
<dt><strong>coeff_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for the random basis coefficients
By default these range from -1.0 to 1.0
Note this is overridden by alg_params (if given there)</p>
</dd>
<dt><strong>num_coeffs</strong><span class="classifier">integer</span></dt><dd><p>Number of coefficients used for each basis function
Note this is calculated automatically based on the dimension of the
dynamics if not given. It is crucial to the performane of the
algorithm that it is set as low as possible, while still giving
high enough frequencies.
Note this is overridden by alg_params (if given there)</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>Multi-variable optimisation method
The only tested options are ‘fmin’ and ‘Nelder-mead’
In theory any non-gradient method implemented in
scipy.optimize.mininize could be used.</p>
</dd>
<dt><strong>method_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the optim_method.
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key
that attribute. Otherwise, and in some case also,
they are assumed to be method_options
for the scipy.optimize.minimize method.
The commonly used parameter are:</p>
<blockquote>
<div><p>xtol - limit on variable change for convergence
ftol - limit on fidelity error change for convergence</p>
</div></blockquote>
</dd>
<dt><strong>phase_option</strong><span class="classifier">string</span></dt><dd><p>determines how global phase is treated in fidelity
calculations (fid_type=’UNIT’ only). Options:</p>
<blockquote>
<div><p>PSU - global phase ignored
SU - global phase included</p>
</div></blockquote>
</dd>
<dt><strong>dyn_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>tslot_type</strong><span class="classifier">string</span></dt><dd><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>guess_pulse_type</strong><span class="classifier">string</span></dt><dd><p>type / shape of pulse(s) used modulate the control amplitudes.
Options include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN</p>
</div></blockquote>
<p>Default is None</p>
</dd>
<dt><strong>guess_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>guess_pulse_action</strong><span class="classifier">string</span></dt><dd><p>Determines how the guess pulse is applied to the pulse generated
by the basis expansion.
Options are: MODULATE, ADD
Default is MODULATE</p>
</dd>
<dt><strong>pulse_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for generated guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset for the pulse. That is this value will be added
to any guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>out_file_ext</strong><span class="classifier">string or None</span></dt><dd><p>files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</dd>
<dt><strong>gen_stats</strong><span class="classifier">boolean</span></dt><dd><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opt</strong><span class="classifier">OptimResult</span></dt><dd><p>Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-qutip.control.pulsegen"></span><p>Pulse generator - Generate pulses for the timeslots
Each class defines a gen_pulse function that produces a float array of
size num_tslots. Each class produces a differ type of pulse.
See the class and gen_pulse function descriptions for details</p>
<dl class="function">
<dt id="qutip.control.pulsegen.create_pulse_gen">
<code class="sig-name descname">create_pulse_gen</code><span class="sig-paren">(</span><em class="sig-param">pulse_type='RND'</em>, <em class="sig-param">dyn=None</em>, <em class="sig-param">pulse_params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#create_pulse_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.create_pulse_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a pulse generator object matching the given type.
The pulse generators each produce a different type of pulse,
see the gen_pulse function description for details.
These are the random pulse options:</p>
<blockquote>
<div><p>RND - Independent random value in each timeslot
RNDFOURIER - Fourier series with random coefficients
RNDWAVES - Summation of random waves
RNDWALK1 - Random change in amplitude each timeslot
RNDWALK2 - Random change in amp gradient each timeslot</p>
</div></blockquote>
<p>These are the other non-periodic options:</p>
<blockquote>
<div><p>LIN - Linear, i.e. contant gradient over the time
ZERO - special case of the LIN pulse, where the gradient is 0</p>
</div></blockquote>
<p>These are the periodic options</p>
<blockquote>
<div><p>SINE - Sine wave
SQUARE - Square wave
SAW - Saw tooth wave
TRIANGLE - Triangular wave</p>
</div></blockquote>
<p>If a Dynamics object is passed in then this is used in instantiate
the PulseGen, meaning that some timeslot and amplitude properties
are copied over.</p>
</dd></dl>

</div>
<div class="section" id="utility-functions">
<h2>Utility Functions<a class="headerlink" href="#utility-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.graph">
<span id="graph-theory-routines"></span><span id="functions-graph"></span><h3>Graph Theory Routines<a class="headerlink" href="#module-qutip.graph" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of graph theory routines used mainly
to reorder matrices for iterative steady state solvers.</p>
<dl class="function">
<dt id="qutip.graph.breadth_first_search">
<code class="sig-name descname">breadth_first_search</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">start</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#breadth_first_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.breadth_first_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting
from a given node (row).  Takes Qobjs and CSR or CSC matrices as inputs.</p>
<p>This function requires a matrix with symmetric structure.
Use A+trans(A) if original matrix is not symmetric or not sure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">csc_matrix, csr_matrix</span></dt><dd><p>Input graph in CSC or CSR matrix format</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Staring node for BFS traversal.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>order</strong><span class="classifier">array</span></dt><dd><p>Order in which nodes are traversed from starting node.</p>
</dd>
<dt><strong>levels</strong><span class="classifier">array</span></dt><dd><p>Level of the nodes in the order that they are traversed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.graph_degree">
<code class="sig-name descname">graph_degree</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#graph_degree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.graph_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree for the nodes (rows) of a symmetric
graph in sparse CSR or CSC format, or a qobj.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj, csr_matrix, csc_matrix</span></dt><dd><p>Input quantum object or csr_matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>degree</strong><span class="classifier">array</span></dt><dd><p>Array of integers giving the degree for each node (row).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.reverse_cuthill_mckee">
<code class="sig-name descname">reverse_cuthill_mckee</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">sym=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#reverse_cuthill_mckee"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.reverse_cuthill_mckee" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the permutation array that orders a sparse CSR or CSC matrix
in Reverse-Cuthill McKee ordering. Since the input matrix must be
symmetric, this routine works on the matrix A+Trans(A) if the sym flag is
set to False (Default).</p>
<p>It is assumed by default (<em>sym=False</em>) that the input matrix is not
symmetric. This is because it is faster to do A+Trans(A) than it is to
check for symmetry for a generic matrix. If you are guaranteed that the
matrix is symmetric in structure (values of matrix element do not matter)
then set <em>sym=True</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">csc_matrix, csr_matrix</span></dt><dd><p>Input sparse CSC or CSR sparse matrix format.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Flag to set whether input matrix is symmetric.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">array</span></dt><dd><p>Array of permuted row and column indices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This routine is used primarily for internal reordering of Lindblad
superoperators for use in iterative solver routines.</p>
<p class="rubric">References</p>
<p>E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric
Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,
(1969).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.maximum_bipartite_matching">
<code class="sig-name descname">maximum_bipartite_matching</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">perm_type='row'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#maximum_bipartite_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.maximum_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of row or column permutations that removes nonzero
elements from the diagonal of a nonsingular square CSC sparse matrix. Such
a permutation is always possible provided that the matrix is nonsingular.
This function looks at the structure of the matrix only.</p>
<p>The input matrix will be converted to CSC matrix format if
necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">sparse matrix</span></dt><dd><p>Input matrix</p>
</dd>
<dt><strong>perm_type</strong><span class="classifier">str {‘row’, ‘column’}</span></dt><dd><p>Type of permutation to generate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">array</span></dt><dd><p>Array of row or column permutations.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function relies on a maximum cardinality bipartite matching algorithm
based on a breadth-first search (BFS) of the underlying graph[1]_.</p>
<p class="rubric">References</p>
<p>I. S. Duff, K. Kaya, and B. Ucar, “Design, Implementation, and
Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.
38, no. 2, (2011).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.weighted_bipartite_matching">
<code class="sig-name descname">weighted_bipartite_matching</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">perm_type='row'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#weighted_bipartite_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.weighted_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of row permutations that attempts to maximize
the product of the ABS values of the diagonal elements in
a nonsingular square CSC sparse matrix. Such a permutation is
always possible provided that the matrix is nonsingular.</p>
<p>This function looks at both the structure and ABS values of the
underlying matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">csc_matrix</span></dt><dd><p>Input matrix</p>
</dd>
<dt><strong>perm_type</strong><span class="classifier">str {‘row’, ‘column’}</span></dt><dd><p>Type of permutation to generate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">array</span></dt><dd><p>Array of row or column permutations.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses a weighted maximum cardinality bipartite matching
algorithm based on breadth-first search (BFS).  The columns are weighted
according to the element of max ABS value in the associated rows and
are traversed in descending order by weight.  When performing the BFS
traversal, the row associated to a given column is the one with maximum
weight. Unlike other techniques[1]_, this algorithm does not guarantee the
product of the diagonal is maximized.  However, this limitation is offset
by the substantially faster runtime of this method.</p>
<p class="rubric">References</p>
<p>I. S. Duff and J. Koster, “The design and use of algorithms for
permuting large entries to the diagonal of sparse matrices”, SIAM J.
Matrix Anal. and Applics. 20, no. 4, 889 (1997).</p>
</dd></dl>

</div>
<div class="section" id="functions-utilities">
<span id="id47"></span><h3>Utility Functions<a class="headerlink" href="#functions-utilities" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-qutip.utilities"></span><p>This module contains utility functions that are commonly needed in other
qutip modules.</p>
<dl class="function">
<dt id="qutip.utilities.n_thermal">
<code class="sig-name descname">n_thermal</code><span class="sig-paren">(</span><em class="sig-param">w</em>, <em class="sig-param">w_th</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#n_thermal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.n_thermal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of photons in thermal equilibrium for an harmonic
oscillator mode with frequency ‘w’, at the temperature described by
‘w_th’ where <span class="math notranslate nohighlight">\(\omega_{\rm th} = k_BT/\hbar\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>w</strong><span class="classifier"><em>float</em> or <em>array</em></span></dt><dd><p>Frequency of the oscillator.</p>
</dd>
<dt><strong>w_th</strong><span class="classifier"><em>float</em></span></dt><dd><p>The temperature in units of frequency (or the same units as <cite>w</cite>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>n_avg</strong><span class="classifier"><em>float</em> or <em>array</em></span></dt><dd><p>Return the number of average photons in thermal equilibrium for a
an oscillator with the given frequency and temperature.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.linspace_with">
<code class="sig-name descname">linspace_with</code><span class="sig-paren">(</span><em class="sig-param">start</em>, <em class="sig-param">stop</em>, <em class="sig-param">num=50</em>, <em class="sig-param">elems=[]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#linspace_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.linspace_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of numbers sampled over specified interval
with additional elements added.</p>
<p>Returns <cite>num</cite> spaced array with elements from <cite>elems</cite> inserted
if not already included in set.</p>
<p>Returned sample array is not evenly spaced if addtional elements
are added.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>The starting value of the sequence.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int</span></dt><dd><p>The stoping values of the sequence.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Number of samples to generate.</p>
</dd>
<dt><strong>elems</strong><span class="classifier">list/ndarray, optional</span></dt><dd><p>Requested elements to include in array</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">ndadrray</span></dt><dd><p>Original equally spaced sample array with additional
elements added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.clebsch">
<code class="sig-name descname">clebsch</code><span class="sig-paren">(</span><em class="sig-param">j1</em>, <em class="sig-param">j2</em>, <em class="sig-param">j3</em>, <em class="sig-param">m1</em>, <em class="sig-param">m2</em>, <em class="sig-param">m3</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#clebsch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.clebsch" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Clebsch-Gordon coefficient
for coupling (j1,m1) and (j2,m2) to give (j3,m3).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j1</strong><span class="classifier">float</span></dt><dd><p>Total angular momentum 1.</p>
</dd>
<dt><strong>j2</strong><span class="classifier">float</span></dt><dd><p>Total angular momentum 2.</p>
</dd>
<dt><strong>j3</strong><span class="classifier">float</span></dt><dd><p>Total angular momentum 3.</p>
</dd>
<dt><strong>m1</strong><span class="classifier">float</span></dt><dd><p>z-component of angular momentum 1.</p>
</dd>
<dt><strong>m2</strong><span class="classifier">float</span></dt><dd><p>z-component of angular momentum 2.</p>
</dd>
<dt><strong>m3</strong><span class="classifier">float</span></dt><dd><p>z-component of angular momentum 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cg_coeff</strong><span class="classifier">float</span></dt><dd><p>Requested Clebsch-Gordan coefficient.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.convert_unit">
<code class="sig-name descname">convert_unit</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">orig='meV'</em>, <em class="sig-param">to='GHz'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#convert_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.convert_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an energy from unit <cite>orig</cite> to unit <cite>to</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">float / array</span></dt><dd><p>The energy in the old unit.</p>
</dd>
<dt><strong>orig</strong><span class="classifier">string</span></dt><dd><p>The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”)</p>
</dd>
<dt><strong>to</strong><span class="classifier">string</span></dt><dd><p>The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>value_new_unit</strong><span class="classifier">float / array</span></dt><dd><p>The energy in the new unit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.fileio">
<span id="file-i-o-functions"></span><span id="functions-fileio"></span><h3>File I/O Functions<a class="headerlink" href="#module-qutip.fileio" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.fileio.file_data_read">
<code class="sig-name descname">file_data_read</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">sep=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#file_data_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.file_data_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves an array of data from the requested file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Name of file containing reqested data.</p>
</dd>
<dt><strong>sep</strong><span class="classifier">str</span></dt><dd><p>Seperator used to store data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array_like</span></dt><dd><p>Data from selected file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.file_data_store">
<code class="sig-name descname">file_data_store</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">data</em>, <em class="sig-param">numtype='complex'</em>, <em class="sig-param">numformat='decimal'</em>, <em class="sig-param">sep='</em>, <em class="sig-param">'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#file_data_store"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.file_data_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores a matrix of data to a file to be read by an external program.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Name of data file to be stored, including extension.</p>
</dd>
<dt><strong>data: array_like</strong></dt><dd><p>Data to be written to file.</p>
</dd>
<dt><strong>numtype</strong><span class="classifier">str {‘complex, ‘real’}</span></dt><dd><p>Type of numerical data.</p>
</dd>
<dt><strong>numformat</strong><span class="classifier">str {‘decimal’,’exp’}</span></dt><dd><p>Format for written data.</p>
</dd>
<dt><strong>sep</strong><span class="classifier">str</span></dt><dd><p>Single-character field seperator.  Usually a tab, space, comma,
or semicolon.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.qload">
<code class="sig-name descname">qload</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#qload"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.qload" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads data file from file named ‘filename.qu’ in current directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of data file to be loaded.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qobject</strong><span class="classifier">instance / array_like</span></dt><dd><p>Object retrieved from requested file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.qsave">
<code class="sig-name descname">qsave</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">name='qutip_data'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#qsave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.qsave" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves given data to file named ‘filename.qu’ in current directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">instance/array_like</span></dt><dd><p>Input Python object to be stored.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Name of output data file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.parallel">
<span id="parallelization"></span><span id="functions-parallel"></span><h3>Parallelization<a class="headerlink" href="#module-qutip.parallel" title="Permalink to this headline">¶</a></h3>
<p>This function provides functions for parallel execution of loops and function
mappings, using the builtin Python module multiprocessing.</p>
<dl class="function">
<dt id="qutip.parallel.parfor">
<code class="sig-name descname">parfor</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/parallel.html#parfor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a multi-variable function in parallel on the local machine.</p>
<p>Parallel execution of a for-loop over function <cite>func</cite> for multiple input
arguments and keyword arguments.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>From QuTiP 3.1, we recommend to use <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.parallel_map</span></code>
instead of this function.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function_type</span></dt><dd><p>A function to run in parallel on the local machine. The function ‘func’
accepts a series of arguments that are passed to the function as
variables. In general, the function can have multiple input variables,
and these arguments must be passed in the same order as they are
defined in the function definition.  In addition, the user can pass
multiple keyword arguments to the function.</p>
</dd>
<dt><strong>The following keyword argument is reserved:</strong></dt><dd></dd>
<dt><strong>num_cpus</strong><span class="classifier">int</span></dt><dd><p>Number of CPU’s to use.  Default uses maximum number of CPU’s.
Performance degrades if num_cpus is larger than the physical CPU
count of your machine.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> with length equal to number of input parameters
containing the output from <cite>func</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.parallel.parallel_map">
<code class="sig-name descname">parallel_map</code><span class="sig-paren">(</span><em class="sig-param">task</em>, <em class="sig-param">values</em>, <em class="sig-param">task_args=()</em>, <em class="sig-param">task_kwargs={}</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/parallel.html#parallel_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.parallel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel execution of a mapping of <cite>values</cite> to the function <cite>task</cite>. This
is functionally equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">task_args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task</strong><span class="classifier">a Python function</span></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values</strong><span class="classifier">array / list</span></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">ProgressBar</span></dt><dd><p>Progress bar class instance for showing progress.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></code> for
each value in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.parallel.serial_map">
<code class="sig-name descname">serial_map</code><span class="sig-paren">(</span><em class="sig-param">task</em>, <em class="sig-param">values</em>, <em class="sig-param">task_args=()</em>, <em class="sig-param">task_kwargs={}</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/parallel.html#serial_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.serial_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Serial mapping function with the same call signature as parallel_map, for
easy switching between serial and parallel execution. This
is functionally equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">task_args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<p>This function work as a drop-in replacement of <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.parallel_map</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task</strong><span class="classifier">a Python function</span></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values</strong><span class="classifier">array / list</span></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">ProgressBar</span></dt><dd><p>Progress bar class instance for showing progress.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.ipynbtools">
<span id="ipython-notebook-tools"></span><span id="functions-ipython"></span><h3>IPython Notebook Tools<a class="headerlink" href="#module-qutip.ipynbtools" title="Permalink to this headline">¶</a></h3>
<p>This module contains utility functions for using QuTiP with IPython notebooks.</p>
<dl class="function">
<dt id="qutip.ipynbtools.parfor">
<code class="sig-name descname">parfor</code><span class="sig-paren">(</span><em class="sig-param">task</em>, <em class="sig-param">task_vec</em>, <em class="sig-param">args=None</em>, <em class="sig-param">client=None</em>, <em class="sig-param">view=None</em>, <em class="sig-param">show_scheduling=False</em>, <em class="sig-param">show_progressbar=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/ipynbtools.html#parfor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <code class="docutils literal notranslate"><span class="pre">tast</span></code> for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code> using a cluster
of IPython engines. The function <code class="docutils literal notranslate"><span class="pre">task</span></code> should have the signature
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">args)</span></code> or <code class="docutils literal notranslate"><span class="pre">task(value)</span></code> if <code class="docutils literal notranslate"><span class="pre">args=None</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">client</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <code class="docutils literal notranslate"><span class="pre">None</span></code>, new instances will be created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task: a Python function</strong></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>task_vec: array / list</strong></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>args: list / dictionary</strong></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function. For example
a dictionary with parameter values.</p>
</dd>
<dt><strong>client: IPython.parallel.Client</strong></dt><dd><p>The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</dd>
<dt><strong>view: a IPython.parallel.Client view</strong></dt><dd><p>The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</dd>
<dt><strong>show_scheduling: bool {False, True}, default False</strong></dt><dd><p>Display a graph showing how the tasks (the evaluation of <code class="docutils literal notranslate"><span class="pre">task</span></code> for
for the value in <code class="docutils literal notranslate"><span class="pre">task_vec1</span></code>) was scheduled on the IPython engine
cluster.</p>
</dd>
<dt><strong>show_progressbar: bool {False, True}, default False</strong></dt><dd><p>Display a HTML-based progress bar duing the execution of the parfor
loop.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of <code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">args)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>, that is, it should be equivalent to
<code class="docutils literal notranslate"><span class="pre">[task(v,</span> <span class="pre">args)</span> <span class="pre">for</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">task_vec]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.ipynbtools.parallel_map">
<code class="sig-name descname">parallel_map</code><span class="sig-paren">(</span><em class="sig-param">task</em>, <em class="sig-param">values</em>, <em class="sig-param">task_args=None</em>, <em class="sig-param">task_kwargs=None</em>, <em class="sig-param">client=None</em>, <em class="sig-param">view=None</em>, <em class="sig-param">progress_bar=None</em>, <em class="sig-param">show_scheduling=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/ipynbtools.html#parallel_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.parallel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <code class="docutils literal notranslate"><span class="pre">task</span></code> for each value in <code class="docutils literal notranslate"><span class="pre">values</span></code> using a cluster
of IPython engines. The function <code class="docutils literal notranslate"><span class="pre">task</span></code> should have the signature
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">client</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <code class="docutils literal notranslate"><span class="pre">None</span></code>, new instances will be created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task: a Python function</strong></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values: array / list</strong></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args: list / dictionary</strong></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs: list / dictionary</strong></dt><dd><p>The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>client: IPython.parallel.Client</strong></dt><dd><p>The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</dd>
<dt><strong>view: a IPython.parallel.Client view</strong></dt><dd><p>The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</dd>
<dt><strong>show_scheduling: bool {False, True}, default False</strong></dt><dd><p>Display a graph showing how the tasks (the evaluation of <code class="docutils literal notranslate"><span class="pre">task</span></code> for
for the value in <code class="docutils literal notranslate"><span class="pre">task_vec1</span></code>) was scheduled on the IPython engine
cluster.</p>
</dd>
<dt><strong>show_progressbar: bool {False, True}, default False</strong></dt><dd><p>Display a HTML-based progress bar during the execution of the parfor
loop.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">task_args,</span> <span class="pre">task_kwargs)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qutip.ipynbtools.version_table">
<code class="sig-name descname">version_table</code><span class="sig-paren">(</span><em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/ipynbtools.html#version_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.version_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print an HTML-formatted table with version numbers for QuTiP and its
dependencies. Use it in a IPython notebook to show which versions of
different packages that were used to run the notebook. This should make it
possible to reproduce the environment and the calculation later on.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>version_table: string</dt><dd><p>Return an HTML-formatted string containing version information for
QuTiP dependencies.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip">
<span id="miscellaneous"></span><span id="functions-misc"></span><h3>Miscellaneous<a class="headerlink" href="#module-qutip" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.about">
<code class="sig-name descname">about</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/about.html#about"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.about" title="Permalink to this definition">¶</a></dt>
<dd><p>About box for QuTiP. Gives version numbers for
QuTiP, NumPy, SciPy, Cython, and MatPlotLib.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.simdiag">
<code class="sig-name descname">simdiag</code><span class="sig-paren">(</span><em class="sig-param">ops</em>, <em class="sig-param">evals=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/simdiag.html#simdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.simdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Simultaneous diagonalization of commuting Hermitian matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ops</strong><span class="classifier">list/array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of qobjs representing commuting Hermitian
operators.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigs</strong><span class="classifier">tuple</span></dt><dd><p>Tuple of arrays representing eigvecs and eigvals of quantum objects
corresponding to simultaneous eigenvectors and eigenvalues for each
operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../changelog.html" class="btn btn-neutral float-right" title="Change Log" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere
      <span class="lastupdated">
        Last updated on Jul 02, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>